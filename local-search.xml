<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nuttx 运行 sqlite</title>
    <link href="/2023/10/14/nuttx%E8%BF%90%E8%A1%8Csqlite/"/>
    <url>/2023/10/14/nuttx%E8%BF%90%E8%A1%8Csqlite/</url>
    
    <content type="html"><![CDATA[<p><strong>絮絮叨叨：</strong></p><p>上一次写 NuttX 的文章还是在 2021 年，那时我接触 NuttX 的只有几个月，当时只写了一个很简单的如何编译一个 “hello world” 的代码。</p><p>现在参与 NuttX 开发已经快有三年的时间了，这段时间里对 NuttX 的了解程度已有很大不同，自己基于 NuttX 也做了一些项目，于是乎这个系列好像可以再更新一下了。</p><h1 id="NuttX-简介"><a href="#NuttX-简介" class="headerlink" title="NuttX 简介"></a>NuttX 简介</h1><p>NuttX 是一个具有丰富功能的、能够运行在小型微控制器上的实时操作系统（RTOS）。它有完整的多线程&#x2F;多进程、文件系统和TCP&#x2F;IP 协议栈的支持，并且实现了所有常用 POSIX API， 能够极大程度的和 Linux 环境开发保持一致。</p><p>下面这篇文章将会体现这种接口兼容性的优点，我们将会在 NuttX 上移植一个完成 SQLite 数据库，并且在 ESP32 上运行和 Linux 一样的 SQLite3 命令行工具。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>开发环境优先推荐使用 Ubuntu 20.04 及以上系统进行开发，其次可以使用 wsl2 进行开发。</p><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a><strong>下载代码</strong></h2><p>这个仓库使用 NuttX release-12.0 代码，并将常用仓库以 git submodules 方式集成，避免每次重新编译需要下载。</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">--recursive</span> git@github.com:Gary-Hobson/NXOS.git</code></pre></div><p>下载代码后需要安装一些基础的依赖库才能进行编译。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><strong>安装依赖</strong></h2><div class="code-wrapper"><pre><code class="hljs mipsasm">sudo apt updatesudo apt <span class="hljs-keyword">install </span>-y \curl <span class="hljs-keyword">bison </span>flex gettext texinfo libncurses5-dev libncursesw5-dev xxd \gperf automake libtool pkg-<span class="hljs-built_in">config</span> <span class="hljs-keyword">build-essential </span>genromfs libx11-dev\libgmp-dev libmpc-dev libmpfr-dev libisl-dev <span class="hljs-keyword">binutils-dev </span>libelf-dev \libexpat-dev gcc-<span class="hljs-keyword">multilib </span>g++-<span class="hljs-keyword">multilib </span>picocom u-<span class="hljs-keyword">boot-tools </span>util-Linux \kconfig-frontends gcc-arm-none-eabi <span class="hljs-keyword">binutils-arm-none-eabi </span>zlib1g-devpip <span class="hljs-keyword">install </span>pyelftools cxxfilt</code></pre></div><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a><strong>编译代码</strong></h2><p>NuttX 有个很强大的功能就是它有一个完成的模拟器支持，如果代码和硬件无关，在模拟器运行成功后，无需任何修改可以运行在硬件上。</p><p>我们首先在 simulator 上编译一个简单的 demo：</p><div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/nx.sh boards/</span>sim<span class="hljs-regexp">/configs/</span>hello V=<span class="hljs-number">1</span></code></pre></div><p>这个将会编译 <code>boards/sim/configs/hello </code> 这个 sim 的配置。 这个配置开启了 sim 环境中包括网络在内的常用功能，大部分与硬件无关的代码可以使用这个配置进行编译运行。</p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a><strong>运行代码</strong></h2><p>在编译完成后，在 NuttX 目录下会出现一个 NuttX 的可执行文件，</p><div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/nuttx/</span>nuttx</code></pre></div><p>NSH 使用 在 NuttX 启动后会出现一个 Shell，它支持基本的命令，nsh 中输入 help 查看支持的所有命令。</p><blockquote><p><strong>help:</strong> 查看支持的所有命令行命令，其中 Builtin Apps 为可执行的 task，例如 hello 为一个独立的 task 可以运行，可以理解为一个进程。<br><strong>ps:</strong> nsh 内置命令，查看正在运行的线程信息<br><strong>ls:</strong> nsh 内置命令，查看文件系统中的文件<br><strong>demo:</strong> 启动 demo 进程，运行后会执行 projects&#x2F;demo&#x2F;main.c 的代码<br><strong>poweroff:</strong> 退出系统</p></blockquote><p>运行后结果：</p><div class="code-wrapper"><pre><code class="hljs bash">NuttShell (NSH)nsh&gt;nsh&gt; <span class="hljs-built_in">help</span><span class="hljs-built_in">help</span> usage:  <span class="hljs-built_in">help</span> [-v] []    .          <span class="hljs-built_in">break</span>      dmesg      hexdump    <span class="hljs-built_in">mkfifo</span>     <span class="hljs-built_in">readlink</span>   <span class="hljs-literal">true</span>    [          <span class="hljs-built_in">cat</span>        <span class="hljs-built_in">echo</span>       insmod     mkrd       <span class="hljs-built_in">rm</span>         <span class="hljs-built_in">truncate</span>    ?          <span class="hljs-built_in">cd</span>         <span class="hljs-built_in">env</span>        <span class="hljs-built_in">kill</span>       mount      <span class="hljs-built_in">rmdir</span>      <span class="hljs-built_in">uname</span>    <span class="hljs-built_in">alias</span>      <span class="hljs-built_in">cp</span>         <span class="hljs-built_in">exec</span>       losetup    <span class="hljs-built_in">mv</span>         rmmod      umount    <span class="hljs-built_in">unalias</span>    cmp        <span class="hljs-built_in">exit</span>       <span class="hljs-built_in">ln</span>         nslookup   <span class="hljs-built_in">set</span>        <span class="hljs-built_in">unset</span>    arp        <span class="hljs-built_in">dirname</span>    <span class="hljs-literal">false</span>      <span class="hljs-built_in">ls</span>         poweroff   <span class="hljs-built_in">sleep</span>      <span class="hljs-built_in">uptime</span>    base64dec  <span class="hljs-built_in">date</span>       free       lsmod      <span class="hljs-built_in">printf</span>     <span class="hljs-built_in">source</span>     usleep    base64enc  <span class="hljs-built_in">dd</span>         memdump    md5        ps         <span class="hljs-built_in">test</span>       wget    <span class="hljs-built_in">basename</span>   <span class="hljs-built_in">df</span>         <span class="hljs-built_in">help</span>       <span class="hljs-built_in">mkdir</span>      <span class="hljs-built_in">pwd</span>        time       xdBuiltin Apps:    demo        hello       ping        sh    dumpstack   nsh         setlogmask  telnetdnsh&gt;nsh&gt; ping www.baidu.comPING 110.242.68.4 56 bytes of data56 bytes from 110.242.68.4: icmp_seq=0 time=19.9 ms56 bytes from 110.242.68.4: icmp_seq=1 time=11.3 ms56 bytes from 110.242.68.4: icmp_seq=2 time=22.7 ms3 packets transmitted, 3 received, 0% packet loss, time 2322 msrtt min/avg/max/mdev = 11.300/17.966/22.700/4.853 msnsh&gt;nsh&gt; <span class="hljs-built_in">ls</span>/: bin/ data/ dev/ etc/ proc/ tmp/nsh&gt;nsh&gt; demoHello, World!!nsh&gt;nsh&gt; poweroff</code></pre></div><p>在上面的运行示例中执行一个 demo 的进程（伪进程，没有独立地址空间），并打印了一个 hello world。</p><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>这个代码位置在 projects&#x2F;demo&#x2F;main.c 里面，可以修改里面代码执行不同的任务。<br>其工程目录结构如下:</p><div class="code-wrapper"><pre><code class="hljs stylus">projects/demo├── Kconfig├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>├── Make<span class="hljs-selector-class">.defs</span>└── Makefile</code></pre></div><p>Make.def 和 Makefile 为编译系统相关文件， <code>PROGNAME</code>  为进程名显示中 nsh 中的名字，<code>PRIORITY</code><br>为任务优先级(0为最低优先级，255为最高优先级，默认为100)， <code>STACKSIZE</code> 为进程栈大小，通过 Kconfig 的配置项决定。</p><div class="code-wrapper"><pre><code class="hljs cpp">cat project/demo/main.c...<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!!\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;# Demo porject...PROGNAME  = demoPRIORITY  = <span class="hljs-number">100</span>STACKSIZE = CONFIG_PROJECT_DEMO_STACKSIZEMAINSRC = main.c</code></pre></div><h1 id="移植-SQLite3"><a href="#移植-SQLite3" class="headerlink" title="移植 SQLite3"></a>移植 SQLite3</h1><p>SQLite 是一个轻量级的关系型数据库，它将数据以单个文件的方式存在与文件系统中。<br>我们这次将示例如何将 SQLite 移植到 NuttX 中运行。</p><p>SQLite 对跨平台做了良好的支持，官方提供了一个移植指南 <a href="https://www.sqlite.org/custombuild.html">https://www.SQLite.org/custombuild.html</a> ，移植 SQLite 只需要实现内存、文件系统和锁相关的支持即可。</p><p>但使用 NuttX 这些工作都可以不需要了，因为它的接口和 Linux 完全一致，不需要做任何修改即可使用。</p><h2 id="下载-SQLite-源码"><a href="#下载-SQLite-源码" class="headerlink" title="下载 SQLite 源码"></a>下载 SQLite 源码</h2><p>SQLite 默认代码有 100多个文件，我们使用 SQLite 官方提供的合并后的文件<a href="https://www.sqlite.org/getthecode.html">https://www.SQLite.org/getthecode.html</a> ，它只有四个文件，将所有代码都合并到一起了(合并之后一个文件20多万行，编译死慢死慢…)</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">SQLite</span><span class="hljs-params">(master)</span></span> ✗: tree -h<span class="hljs-selector-attr">[4.0K]</span>  .├── <span class="hljs-selector-attr">[862K]</span>  shell<span class="hljs-selector-class">.c</span>├── <span class="hljs-selector-attr">[8.4M]</span>  SQLite3<span class="hljs-selector-class">.c</span>├── <span class="hljs-selector-attr">[ 37K]</span>  SQLite3ext<span class="hljs-selector-class">.h</span>└── <span class="hljs-selector-attr">[614K]</span>  SQLite3.h</code></pre></div><p>然后我们参考 demo 的项目结构，将它添加到编译系统中:</p><div class="code-wrapper"><pre><code class="hljs makefile">├── Kconfig├── Make.defs├── Makefile├── SQLite├── SQLite_cfg.hcat MakefileCSRCS += SQLite/SQLite3.cCFLAGS += -I$&#123;LIBRARIESDIR&#125;/SQLiteCFLAGS += -D_HAVE_SQLite_CONFIG_H<span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CONFIG_TOOLS_SQLite)</span>, y)PROGNAME  = SQLite3PRIORITY  = 100STACKSIZE = $&#123;CONFIG_TOOLS_SQLite_STACKSIZE&#125;MAINSRC = SQLite/shell.c<span class="hljs-keyword">endif</span></code></pre></div><p>SQLite 提供了一个命令行文件和一个库文件，我们将这两个分别添加到编译系统中，然后即可编译。<br>SQLite_cfg.h 是 SQLite 的配置文件，可以对他进行修改以进行裁剪，选择所需要的功能， 它的可选配置可以参考<a href="https://www.sqlite.org/compile.html">Compile-time Options</a>.</p><h2 id="运行-SQLite"><a href="#运行-SQLite" class="headerlink" title="运行 SQLite"></a>运行 SQLite</h2><p>同样的我们先在 sim 中运行， 先基于 board&#x2F;sim&#x2F;configs&#x2F;hello 的配置开启下面两个配置，然后编译运行。</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_LIB_SQLITE</span>=y<span class="hljs-attr">CONFIG_TOOLS_SQLITE</span>=y</code></pre></div><p>然后我们就可以在 NuttX 中和 Linux 一样的运行 SQLite 命令行工具了。<br>启动之后和之前一样会进入 NSH Shell，然后我们输入 sqlite3 就可以进入 SQLite 的命令行工具了。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">NuttShell</span> (NSH)<span class="hljs-attribute">nsh</span>&gt;<span class="hljs-attribute">nsh</span>&gt; uname -a<span class="hljs-attribute">NuttX</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">6</span>cdde97822 Oct  <span class="hljs-number">5</span> <span class="hljs-number">2023</span> <span class="hljs-number">17</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53</span> xtensa ESP32-devkitc<span class="hljs-attribute">nsh</span>&gt;<span class="hljs-attribute">nsh</span>&gt; cd data<span class="hljs-attribute">nsh</span>&gt; help<span class="hljs-attribute">Builtin</span> Apps:    <span class="hljs-attribute">demo</span>        hello       ping        sh          telnetd    <span class="hljs-attribute">dumpstack</span>   nsh         setlogmask  sqlite3<span class="hljs-attribute">nsh</span>&gt;</code></pre></div><p>我们先进入 &#x2F;data 目录，以便后面的操作可以持久化到文件系统中。<br>在 sqlite3 的命令行中输入 .help 可以查看所有支持的命令。</p><p>使用 .open 命令打开一个数据库文件，如果文件不存在则会创建一个新的数据库文件, 然后退出 sqlite3 命令行工具，在 &#x2F;data 目录下会出现一个 test.db 的文件</p><div class="code-wrapper"><pre><code class="hljs stata">nsh&gt; sqlite3SQLite <span class="hljs-keyword">version</span> 3.43.1 2023-09-11 12:01:27Enter <span class="hljs-string">&quot;.help&quot;</span> <span class="hljs-keyword">for</span> usage hints.Connected to a transient <span class="hljs-keyword">in</span>-<span class="hljs-keyword">memory</span> database.<span class="hljs-keyword">Use</span> <span class="hljs-string">&quot;.open FILENAME&quot;</span> to reopen <span class="hljs-keyword">on</span> a persistent database.sqlite&gt; .<span class="hljs-keyword">open</span> <span class="hljs-keyword">test</span>.<span class="hljs-keyword">db</span>sqlite&gt;.quitnsh&gt; <span class="hljs-keyword">ls</span>/data: . .. <span class="hljs-keyword">test</span>.<span class="hljs-keyword">db</span></code></pre></div><p>我们再次进入 sqlite3 命令行工具，并创建一个表，使用 .tables 命令查看所有的表，可以看到我们刚才创建的 COMPANY 表。</p><div class="code-wrapper"><pre><code class="hljs sql">sqlite<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY((x1...<span class="hljs-operator">&gt;</span>    ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,(x1...<span class="hljs-operator">&gt;</span>    NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,(x1...<span class="hljs-operator">&gt;</span>    AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,(x1...<span class="hljs-operator">&gt;</span>    ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),(x1...<span class="hljs-operator">&gt;</span>    SALARY         <span class="hljs-type">REAL</span>(x1...<span class="hljs-operator">&gt;</span> );sqlite<span class="hljs-operator">&gt;</span>sqlite<span class="hljs-operator">&gt;</span> .tablesCOMPANYsqlite<span class="hljs-operator">&gt;</span></code></pre></div><p>接着我们可以插入一些数据，然后使用 SELECT 命令查看数据。</p><div class="code-wrapper"><pre><code class="hljs sql">sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)   ...<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );sqlite<span class="hljs-operator">&gt;</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Alsqlite&gt;    ...&gt; len&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">15000.00</span> );sqlite<span class="hljs-operator">&gt;</span>sqlite<span class="hljs-operator">&gt;</span>sqlite<span class="hljs-operator">&gt;</span> .header <span class="hljs-keyword">on</span>sqlite<span class="hljs-operator">&gt;</span> .mode <span class="hljs-keyword">column</span>sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> COMPANY;ID  NAME   AGE  ADDRESS     SALARY<span class="hljs-comment">--  -----  ---  ----------  -------</span><span class="hljs-number">1</span>   Paul   <span class="hljs-number">32</span>   California  <span class="hljs-number">20000.0</span><span class="hljs-number">2</span>   Allen  <span class="hljs-number">25</span>   Texas       <span class="hljs-number">15000.0</span></code></pre></div><p>以上 sqlite3 的命令行工具的使用和 Linux 上的使用完全一致，甚至你可以将 linux 的 .db 文件拷贝到 NuttX 中使用。</p><h1 id="ESP32-运行-SQLite"><a href="#ESP32-运行-SQLite" class="headerlink" title="ESP32 运行 SQLite"></a>ESP32 运行 SQLite</h1><h2 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h2><div class="code-wrapper"><pre><code class="hljs bash">pip install esptool<span class="hljs-built_in">mkdir</span> -p ~/.toolchain;<span class="hljs-built_in">cd</span> ~/.toolchainwget https://github.com/espressif/crosstool-NG/releases/download/esp-12.2.0_20230208/xtensa-esp32-elf-12.2.0_20230208-x86_64-Linux-gnu.tar.xztar -xf ./xtensa-esp32-elf-12.2.0_20230208-x86_64-Linux-gnu.tar.xz<span class="hljs-built_in">rm</span> xtensa-esp32-elf-12.2.0_20230208-x86_64-Linux-gnu.tar.xz<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=\&quot;\$HOME/.toolchain/xtensa-esp32-elf/bin:\$PATH\&quot;&quot;</span> &gt;&gt; ~/.profile<span class="hljs-built_in">source</span> ~/.profile</code></pre></div><p>这里我使用的 ESP32 开发版是  ESP-WROOM-32,它有 4MB (32Mb) 的 SPI Flash和520KB SRAM。</p><p><img src="https://files.mdnice.com/user/11205/0eefd057-189c-4878-be7a-b583b9c7ce7b.png"></p><h2 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h2><p>在这个配置中将将 1M 的 FALSH 作为了 代码空间，1M 的 FLASH 作为文件系统(Littlefs)。挂载到 &#x2F;data 目录</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 编译 SQLite 配置</span>./nx.sh boards/esp32/configs/sqlite</code></pre></div><p>使用上面的编译命令编译后会在 NuttX 目录下生成一个 NuttX.bin 文件， 然后我们需要将它烧录到设备中. 下面的的 &#x2F;dev&#x2F;ttyUSB0 需要根据实际情况填写。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># ubuntu，下载固件到设备</span>esptool.py -c esp32 -p /dev/ttyUSB0 -b 921600  write_flash -fs detect -fm dio -ff 40m 0x1000 boards/esp32/boot/bootloader-esp32.bin 0x8000 boards/esp32/boot/partition-table-esp32.bin 0x10000 nuttx/nuttx.bin</code></pre></div><p>烧录后打开串口终端，和上面执行相同的步骤可以体验在 ESP32 上使用 SQLite 的命令行工具.(上面实际就是 ESP32 上运行的结果)</p><h2 id="在代码中使用"><a href="#在代码中使用" class="headerlink" title="在代码中使用"></a>在代码中使用</h2><p>在 NuttX 中使用 SQLite 也和 Linux 一样，只需要在代码中包含 sqlite3.h 头文件即可。<br>例如我们在 demo 项目中添加一个 sqlite3 的 demo，代码如下:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sqlite3.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *NotUsed, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv,</span></span><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">char</span> **azColName)</span> </span>&#123;    NotUsed = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="hljs-string">&quot;NULL&quot;</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;    sqlite3 *db;    <span class="hljs-type">char</span> *err_msg = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">sqlite3_open</span>(<span class="hljs-string">&quot;test.db&quot;</span>, &amp;db);    <span class="hljs-keyword">if</span> (rc != SQLITE_OK) &#123;        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Cannot open database: %s\n&quot;</span>,                <span class="hljs-built_in">sqlite3_errmsg</span>(db));        <span class="hljs-built_in">sqlite3_close</span>(db);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">char</span> *sql = <span class="hljs-string">&quot;SELECT * FROM Cars&quot;</span>;    rc = <span class="hljs-built_in">sqlite3_exec</span>(db, sql, callback, <span class="hljs-number">0</span>, &amp;err_msg);    <span class="hljs-keyword">if</span> (rc != SQLITE_OK ) &#123;        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Failed to select data\n&quot;</span>);        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;SQL error: %s\n&quot;</span>, err_msg);        <span class="hljs-built_in">sqlite3_free</span>(err_msg);        <span class="hljs-built_in">sqlite3_close</span>(db);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">sqlite3_close</span>(db);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在上面的代码中我们使用了一个 callback 函数，这个函数是在执行 SELECT 命令后的回调函数，它会将查询的结果打印出来。</p><p>运行结果如下:</p><div class="code-wrapper"><pre><code class="hljs abnf">nsh&gt; cd datansh&gt; demo<span class="hljs-attribute">Id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-attribute">Name</span> <span class="hljs-operator">=</span> Audi<span class="hljs-attribute">Price</span> <span class="hljs-operator">=</span> <span class="hljs-number">52642</span><span class="hljs-attribute">Id</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-attribute">Name</span> <span class="hljs-operator">=</span> Mercedes<span class="hljs-attribute">Price</span> <span class="hljs-operator">=</span> <span class="hljs-number">57127</span><span class="hljs-attribute">Id</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-attribute">Name</span> <span class="hljs-operator">=</span> Skoda<span class="hljs-attribute">Price</span> <span class="hljs-operator">=</span> <span class="hljs-number">9000</span>...</code></pre></div><h2 id="资源占用"><a href="#资源占用" class="headerlink" title="资源占用"></a>资源占用</h2><p>在 ESP32 编译后比较开启 SQLite 前后的资源占用，SQLite 占用大概 600K 的 FLASH 和 70K 的 RAM<br>如果对 sqlite_cfg.h 进行配置后，可以进一步裁剪降低  FLASH 的占用。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">NXOS</span><span class="hljs-params">(master)</span></span> ✗: size hello<span class="hljs-selector-class">.elf</span>   text    data     bss     dec     hex filename <span class="hljs-number">110672</span>     <span class="hljs-number">532</span>    <span class="hljs-number">9632</span>  <span class="hljs-number">120836</span>   <span class="hljs-number">1</span>d804 hello<span class="hljs-selector-class">.elf</span><span class="hljs-function"><span class="hljs-title">NXOS</span><span class="hljs-params">(master)</span></span> ✗: size sqlite<span class="hljs-selector-class">.elf</span>   text    data     bss     dec     hex filename <span class="hljs-number">671310</span>    <span class="hljs-number">7664</span>   <span class="hljs-number">10680</span>  <span class="hljs-number">689654</span>   a85f6 sqlite.elf</code></pre></div><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>前段时间有人在公众号的后台问我，有没有关于 NuttX 的视频，我在网上搜了一下关于 NuttX 使用视频实在少得可怜。</p><p>而我在 21 年的立的 flag 中就有关于发布一个视频，这次国庆假期总算有机会可以拔了这个 flag 了。</p><p>视频的话明天会发出，如果对于这个文章有任何问题可以点击阅读原文到 github 进行评论交流（公众号注册太迟，没有留言功能😢）</p>]]></content>
    
    
    
    <tags>
      
      <tag>nuttx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言调用规约之函数入参顺序</title>
    <link href="/2022/09/04/C%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6%E4%B9%8B%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/09/04/C%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6%E4%B9%8B%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><p>在 IA-32 平台上有三种入参方式，stdcall、cdecl、fastcall，前两种参数入参顺序均为<strong>从右至左</strong>压栈，fastcall 前两个参数使用寄存器，后面参数<strong>从右至左</strong>压栈。<br>C&#x2F;C++ 默认使用 cdecl 方式，MSVC 编译器默认使用 stdcall 。</p></li><li><p>x64 平台只有一种入参方式，即 fastcall 方式，前四个参数使用寄存器保存，后面参数后<strong>从右至左</strong>压栈。</p></li><li><p>ARM 32位平台，前四个参数使用寄存器保存，后面参数后<strong>从右至左</strong>压栈。</p></li><li><p>ARM 64位平台，前8个参数使用寄存器保存 ，后面参数<strong>从右往左</strong>入栈。</p></li><li><p>使用浮点数时，同上规则使用浮点寄存器，不占用对应的整型寄存器。</p></li><li><p>如果参数大小小于芯片位长，则会自动提升为位长对应大小。</p></li><li><p>参数中包含结构体时，且大小大于芯片位长时，x64 会将参数压入栈中，并在寄存器中保存指向该内存的指针。</p></li><li><p>参数中包含结构体时，且大小大于芯片位长时，ARM 在剩余寄存器可用时，将结构体放入连续寄存器。否则将剩余参数压入栈中。</p></li><li><p>以上所有结构体在栈中会按芯片位长进行对齐。</p></li><li><p>以上所有平台函数返回值使用前两个寄存器，当返回结果小于芯片位长时使用第一个寄存器，小于芯片位长两倍时使用前两个寄存器。<br>返回结构体，且结构体大小大于芯片位长两倍时，返回结果保存在栈中，并在第一个寄存器中保存执行该内存的指针。</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>aapcs32 调用规约文档<br><code>https://github.com/ARM-software/abi-aa/blob/2bcab1e3b22d55170c563c3c7940134089176746/aapcs32/aapcs32.rst#6the-base-procedure-call-standard</code></p><p>aapcs64 调用规约文档<br><code>https://github.com/ARM-software/abi-aa/blob/2bcab1e3b22d55170c563c3c7940134089176746/aapcs64/aapcs64.rst#6the-base-procedure-call-standard</code></p><p>MSVC 关于不同平台的调用文档：<br><code>https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160</code></p><p>Intel 调用规约文档：<br><code>https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/c-c-calling-conventions.html</code></p><p>wikipedia x86 调用规约介绍<br><code>https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MCU自动下载原理及实现</title>
    <link href="/2022/09/04/MCU%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/04/MCU%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>串口自动下载电路实质为：<strong>上位机通过控制 USB 转串口芯片 DTR、RTS 引脚电平，配合硬件电路使进入芯片下载模式</strong></p><h2 id="自动下载原理"><a href="#自动下载原理" class="headerlink" title="自动下载原理"></a>自动下载原理</h2><p>串口下载的需要依赖 bootload，其流程为在芯片中先下载一个 bootload , 进入 bootload 后检查是否进入下载模式，如果未进入下载程序，则跳转到实际程序运行。</p><p>根据进入 bootload 的方式可分为两种，一种为进入 bootload 由外部引脚控制，例如 STM32 和 ESP8266。<br>一种是系统复位时默认进入 bootload ，例如 STC 的 51 系列和一些自定义的 bootload 。</p><p>以 STM32 为例，在芯片出厂时在其系统存储区烧录了一个 bootload ，并通过其 boot0 和 boot1 引脚电平进行选择复位后进入的存储器。</p><p><img src="https://files.mdnice.com/user/11205/62c1a21e-888c-4b4a-8711-ce934e6c1292.png"></p><p>对于自定义 bootload ，只能在系统复位时进入 bootload ,然后在 bootload 中进行进一步判断处理。</p><p>自动下载功能需要硬件和软件两部分支持，软件部分包括由上位机提供的串口下载协议和串口流控信号。<br>自动下载硬件电路将串口流控信号，转换为对于芯片所需的复位信号和boot引脚信号。</p><p>在串口下载的上位机程序中，需要控制串口的 DTR(Data Terminal Ready)、RTS(Request To Send) 引脚提供下载开始信号，然后由硬件电路转换为对应的复位信号和 boot 信号。</p><h2 id="ESP8266-的自动下载原理分析"><a href="#ESP8266-的自动下载原理分析" class="headerlink" title="ESP8266 的自动下载原理分析"></a>ESP8266 的自动下载原理分析</h2><p>以 ESP8266 为例，ESP8266 进入下载模式的条件为 GPIO0 引脚为低电平时，复位芯片( RST\EN 上升沿)。  即 GPIO0 &#x3D; 0  RST &#x3D; 0 -&gt; 1</p><p>NodeMCU 的自动下载电路如下如所示：</p><p><img src="https://files.mdnice.com/user/11205/9e9cf6af-1a8a-44cb-9d84-b4375a04fc4c.png"></p><p>GPIO0 和 RST 默认电平为高电平，且需要注意到 RST 引脚有一个复位电路。</p><p>其复位延时时间约为 1.15 ms。</p><p>其自动复位电路类似三极管双稳态电路：</p><blockquote><ol><li>当 DTR &#x3D; 1,RTS &#x3D; 1 时, VT1截止，VT2截止, RST &#x3D; 1; GPIO0 &#x3D; 1</li><li>当 DTR &#x3D; 0,RTS &#x3D; 0 时, VT1截止，VT2截止, RST &#x3D; 1; GPIO0 &#x3D; 1</li><li>当 DTR &#x3D; 1,RTS &#x3D; 0 时, VT1导通，VT2截止, RST &#x3D; 0; GPIO0 &#x3D; 1</li><li>当 DTR &#x3D; 0,RTS &#x3D; 1 时, VT1截止，VT2导通, RST &#x3D; 1; GPIO0 &#x3D; 0</li></ol></blockquote><p>其真值表为：</p><p><img src="https://files.mdnice.com/user/11205/c7531902-9c99-4a44-99e5-2d6d6e572f0d.png"></p><p>在状态 3) 下载电路 RST 引脚为低，进入复位模式；<br>在状态 4) 下载电路 GPIO0 引脚为低。</p><p>由于 RST 引脚带有复位电路，在 RST 引脚电平变为高电平后，会有一段时间延时才能恢复高电平。所以只需要在上位机代码中控制 DTR&amp;RTS 引脚电平，依次进入状态3和状态4，ESP8266 就可以进入下载模式。</p><p>查看 ESP8266 下载工具 pytool.py 代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 已删减无关代码，原代码 https://hub.fastgit.org/espressif/esptool/blob/master/esptool.py#L570</span><span class="hljs-comment"># RTS = either CH_PD/EN or nRESET (both active low = chip in reset</span><span class="hljs-comment"># DTR = GPIO0 (active low = boot to flasher)</span><span class="hljs-comment"># DTR &amp; RTS are active low signals,</span><span class="hljs-comment"># ie True = pin @ 0V, False = pin @ VCC.</span><span class="hljs-comment"># 进入状态 3)</span>self._setDTR(<span class="hljs-literal">False</span>)  <span class="hljs-comment"># IO0=HIGH</span>self._setRTS(<span class="hljs-literal">True</span>)   <span class="hljs-comment"># EN=LOW, chip in reset</span>time.sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment"># 进入状态 4)</span>self._setDTR(<span class="hljs-literal">True</span>)   <span class="hljs-comment"># IO0=LOW</span>self._setRTS(<span class="hljs-literal">False</span>)  <span class="hljs-comment"># EN=HIGH, chip out of reset</span>time.sleep(<span class="hljs-number">0.05</span>)<span class="hljs-comment"># 恢复 Flash 启动模式</span>self._setDTR(<span class="hljs-literal">False</span>)  <span class="hljs-comment"># IO0=HIGH, done</span></code></pre></div><p>使用逻辑分析仪抓取的下载时的 DTR、RTS 信号如下图所示。</p><p><img src="https://files.mdnice.com/user/11205/0fc2f569-d42f-49da-a6e6-dce86d4f3d8b.png"></p><p>其中红框所标识的就是状态 3 -&gt; 4 的变化。<br>由于执行代码也需要时间，实际状态变化并不是由状态3直接进入状态4，但是状态1和2并不会对下载电路产生影响。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于不需要 boot 引脚即可进入下载模式的bootload，其自动下载同样是使用上位机控制 DTR\RTS 引脚，只不过它只需要使用一个引脚让芯片在下载前进入复位模式即可。</p><p>通过上面分析，就可以解释为什么有时在使用串口软件打开串口后，芯片会自动复位。<br>这是因为在串口软件中默认开启了流控，其流控引脚导致芯片进入复位状态，所以只需关闭串口软件流控，即可避免该现象发生。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Protobuf文件的编写</title>
    <link href="/2022/09/04/Protobuf%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <url>/2022/09/04/Protobuf%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>数据从 SLPI 侧上报到 HAL 层，都需要从底层使用pb接口，将规定的数据格式 publish 上来，在HAL层再通过调用同样的数据格式的接口解析出数据。</p><p>数据格式的定义——Protobuf文件的编写</p><h2 id="什么是Protobuf？"><a href="#什么是Protobuf？" class="headerlink" title="什么是Protobuf？"></a>什么是Protobuf？</h2><p>Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的序列化结构的数据格式，用于将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构。</p><p>故适合在不同应用之间相互通信的数据交换格式，需要定义数据格式的.proto文件，编译后即可解析。支持的语言(Java、Python、C&#x2F;C++等)文件;</p><h2 id="Protobuf-语法"><a href="#Protobuf-语法" class="headerlink" title="Protobuf 语法"></a>Protobuf 语法</h2><p>使用 protobuf 前需要定义一个 .proto 文件，内容表示消息的格式，下面以一个简单的 demo 举例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// syntax关键词定义使用的是proto3语法版本</span>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-comment">// message关键词，标记开始定义一个消息</span>message Student&#123;<span class="hljs-comment">// 字段类型 名字 = 唯一标识号</span>    <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;    int32 age = <span class="hljs-number">2</span>;&#125;</code></pre></div><p>第一行 syntax 指定了要用 proto 的语法，proto3即为proto3对应的语法。</p><p>message 表示消息类型，可以有很多个。其结构与 C 语言结构体很相似<br>Student 表示消息名称，类似于 C 语言结构体的名称</p><p>字段类型：用于表示字段的数据类型，包括 string、int32、uint32、float、double、bool、bytes 等等 ，含义和类型名和 C 语言非常相似。<br>唯一标识号：在消息定义中，每个字段后面都有一个唯一的标识号，标识号是用于消息的二进制格式中识别各个字段。</p><p>以上就是 protobuf 最简单的语法。</p><h2 id="protobuf-c-的使用"><a href="#protobuf-c-的使用" class="headerlink" title="protobuf-c 的使用"></a>protobuf-c 的使用</h2><p>在默认安装的 protobuf 中支持了 C++、java、ptython、rust 众多语言，唯独没有支持 C 语言，在 C 语言中使用 protobuf 需要单独编译安装 protobuf-c。</p><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># protobuf-c 需要 protobuf</span>sudo apt install protobuf-compiler<span class="hljs-comment"># 一键三连安装 protobuf-c</span>git <span class="hljs-built_in">clone</span> https://github.com/protobuf-c/protobuf-c.git &amp;&amp; <span class="hljs-built_in">cd</span> protobuf-c./autogen.sh &amp;&amp; ./configuremake -j &amp;&amp; sudo make install</code></pre></div><p>安装完成后，protobuf-c 和其它语言的编译一样，指定需要编译的文件和输出的文件类型即可。</p><div class="code-wrapper"><pre><code class="hljs sh">protoc-c demo.proto  --c_out=.</code></pre></div><p>protoc-c 是 .proto C 语言的编译器, –c_out 指定输出的文件类型和输出路径</p><p>编译完成后，会在指定的路径生成两个文件：demo.pb-c.c 、demo.pb-c.h ，这两个文件分别为打包和解析消息的代码，其编译完头文件提供了以下方法：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// demo.pb-c.h</span><span class="hljs-comment">/* Student methods */</span><span class="hljs-type">void</span> <span class="hljs-title function_">student__init</span><span class="hljs-params">(Student *message)</span>;<span class="hljs-type">size_t</span> <span class="hljs-title function_">student__get_packed_size</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *message)</span>;<span class="hljs-type">size_t</span> <span class="hljs-title function_">student__pack</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *message, <span class="hljs-type">uint8_t</span> *out)</span>;<span class="hljs-type">size_t</span> <span class="hljs-title function_">student__pack_to_buffer</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *message, ProtobufCBuffer *buffer)</span>;Student *<span class="hljs-title function_">student__unpack</span><span class="hljs-params">(ProtobufCAllocator *allocator, <span class="hljs-type">size_t</span> len,</span><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">student__free_unpacked</span><span class="hljs-params">(Student *message, ProtobufCAllocator *allocator)</span>;</code></pre></div><p>下面使用这些 API 写一个简单的 demo</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;demo.pb-c.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  Student student = STUDENT__INIT;  <span class="hljs-type">void</span> *buffer = <span class="hljs-literal">NULL</span>;  <span class="hljs-type">int32_t</span> len;  Student *msg = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化数据</span>  student.name = <span class="hljs-string">&quot;student&quot;</span>;  student.age = <span class="hljs-number">28</span>;  <span class="hljs-comment">// 打包数据</span>  len = student__get_packed_size(&amp;student);  buffer = <span class="hljs-built_in">malloc</span>(len);  student__pack(&amp;student, buffer);  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 发送数据到远端设备</span>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从远端设备接受数据</span>  <span class="hljs-comment">// 解包数据</span>  msg = student__unpack(<span class="hljs-literal">NULL</span>, len, buffer);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student name : %s, age : %d\n&quot;</span>, student.name, student.age);  <span class="hljs-comment">// 释放资源</span>  student__free_unpacked(msg, <span class="hljs-literal">NULL</span>);  <span class="hljs-built_in">free</span>(buffer);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>有人简单做了一个各种通用序列化协议技术的对比，在几个比较项中 protobuf 的序列化和反序列化性能都是最优秀的，同时占用的体积却非常小。<br><img src="https://files.mdnice.com/user/11205/88b88a17-671b-4009-9f02-34c44f62f048.png" alt="https://www.iteye.com/blog/agapple-859052"></p><p><img src="https://files.mdnice.com/user/11205/264e7162-91b6-44c5-854f-c0a9f42628cb.png" alt="https://www.iteye.com/blog/agapple-859052"></p><p>在 github 上有更详细完整的性能对比：<a href="https://github.com/eishay/jvm-serializers/wiki%EF%BC%8C%E5%8F%AF%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B%E3%80%82">https://github.com/eishay/jvm-serializers/wiki，可进行查看。</a></p><h2 id="嵌入式使用"><a href="#嵌入式使用" class="headerlink" title="嵌入式使用"></a>嵌入式使用</h2><p>在了解完 protobuf 的基本使用后，考虑如何在嵌入式设备上使用时，发现 protobuf 很难在一般的小型嵌入式设备上使用。</p><p>因为其几百K的代码大小，已经超过不少芯片 Flash 的大小了，但是查找资料时发现了替代品： nanopb 。</p><p>nanopb 的使用和 .proto 的语法与 protobuf 一致, 一共三个核心文件，编译后的代码不到 10K，非常适合在在嵌入式环境下使用。<br>当然缺点还是有的，就是用时间换空间，序列化和反序列化时间相对较长，不过比 json 等格式仍然快上不少。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STM32上使用POSIX接口</title>
    <link href="/2022/09/04/STM32%E4%B8%8A%E4%BD%BF%E7%94%A8POSIX%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/09/04/STM32%E4%B8%8A%E4%BD%BF%E7%94%A8POSIX%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32上使用POSIX接口"><a href="#STM32上使用POSIX接口" class="headerlink" title="STM32上使用POSIX接口"></a>STM32上使用POSIX接口</h1><p><strong>絮絮叨叨</strong>：如果不是博客粉丝，我都快要遗忘公众号这回事了，感谢所有认真阅读的读者的支持！</p><h2 id="FreeRTOS-和-POSIX-接口简介"><a href="#FreeRTOS-和-POSIX-接口简介" class="headerlink" title="FreeRTOS 和 POSIX 接口简介"></a>FreeRTOS 和 POSIX 接口简介</h2><p>POSIX 接口的全称是：可移植性操作系统接口(Portable Operating System Interface, POSIX)。它是由电器和电子工程师协会(IEEE)开发的开放操作系统接口标准，并且得到 IOS 和 ANSI 的认可。</p><p>其主要目的是提升应用程序在各种 UNIX 系统环境之间的可移植性。使用 POSIX 接口开发的程序，可以在支持的平台方便进行移植。</p><p>FreeRTOS 是一款广泛使用于微控制器的开源实时操作系统，其具有极简的内核，几个文件中包含了：任务管理、时间管理、信号量、消息队列、内存管理、软件定时器，实现了实时操作系统的核心功能。</p><h2 id="FreeRTOS-的-POSIX-接口层"><a href="#FreeRTOS-的-POSIX-接口层" class="headerlink" title="FreeRTOS 的 POSIX 接口层"></a>FreeRTOS 的 POSIX 接口层</h2><p>在开发使用第三方库时，会遇到许多库都是运行在 linux 平台下，基于 posix 接口开发的。而在 FreeRTOS 内核的 API 是不兼容 POSIX 接口的。</p><p><img src="https://files.mdnice.com/user/11205/c684442f-ad22-49a7-bd5a-c833e6cd79b2.png"></p><p>但是在官方提供的 Library 中，包含了标准 POSIX 的线程兼容库，其满足 POSIX IEEE Std 1003.1-2017 标准。<br>支持的头文件列表如下：.<br><img src="https://files.mdnice.com/user/11205/574a2dd8-9f89-42f6-9cdb-40d2f7934c73.png"></p><p><strong>必须强调的是</strong>: 尽管在 FreeRTOS 的 POSIX 支持库中提供了 &lt;fcntl.h&gt; 的头文件，但是其中只包含了文件操作选项的宏定义，并未提供文件访问操作的一系列 API (open, read, write, ioctl等)。</p><h2 id="在-STM32-上使用-POSIX"><a href="#在-STM32-上使用-POSIX" class="headerlink" title="在 STM32 上使用 POSIX"></a>在 STM32 上使用 POSIX</h2><p>在官方提供的 POSIX 库的代码中并没有移植到 STM32, 而是提供了一个 VS Simulation，所以在 stm32 中使用该功能还是需要进行移植。</p><p>不过移植过程相对比较简单，只需要将 POSIX 库的源文件和头文件添加到工程中，并开启configUSE_POSIX_ERRNO 和 configUSE_APPLICATION_TASK_TAG 两个配置宏。</p><p>在移植时需要注意 FreeRTOS 的版本是否兼容，STM32CubeMX 默认的 FreeRTOS 库由于版本过低，无法直接使用。</p><p>我在移植时，使用 Cube 默认生成的 FreeRTOS 工程文件，然后使用 Simulation 中的文件替换原有文件进行的。</p><p>在阅读原文链接中，为移植好的 stm32 demo 工程和官方提供的 VS Simulation 工程。</p><p><a href="https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html" title="官方链接"></a><br><a href="POSIX%E5%92%8CRTOS" title="《实时嵌入式系统 设计原则与工程实践》"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>X86 寄存器及寻址方式</title>
    <link href="/2022/09/04/X86%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/09/04/X86%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="X86-寄存器及寻址方式"><a href="#X86-寄存器及寻址方式" class="headerlink" title="X86 寄存器及寻址方式"></a>X86 寄存器及寻址方式</h1><p><strong>絮絮叨叨</strong>：之前看的汇编都是 ARM Cotex M 系列，在调试任务切换时，不得不学习一下 x86 的汇编。</p><h2 id="x86-寄存器列表"><a href="#x86-寄存器列表" class="headerlink" title="x86 寄存器列表"></a>x86 寄存器列表</h2><p>inter i386 平台下寄存器包括 8 个 32 位的通用寄存器、8 个调试寄存器、6 个 16 位的段寄存器、4 个 32 位的控制寄存器等寄存器<a href="https://www.cnblogs.com/wang-can/p/3369184.html" title="i386的寄存器"></a>。</p><p>使用最多的时 8 个通用寄存器，EAX、ECX、EDX、EBX、ESI、EDI、ESP、EBP 和一个程序指针寄存器 EIP。</p><p>8 个通用寄存器可以作为 16 位（字）或者 32 位（双字）进行访问，同时可以独立访问前四个寄存器（EAX、ECX、EDX、EBX）的低两字节。<a href="3.4%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF" title="《深入理解计算机系统》"></a></p><p><img src="https://imgkr2.cn-bj.ufileos.com/92d882a0-aacc-43fa-ab73-6e6a0bed9102.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=Tw%252Fn4fvlER0Of5T1DBLVG3qkbEw%253D&Expires=1615134780" alt="x86 通用寄存器"></p><h2 id="x86-寄存器功能"><a href="#x86-寄存器功能" class="headerlink" title="x86 寄存器功能"></a>x86 寄存器功能</h2><p>x86 寄存器功能列表如下：</p><table><thead><tr><th>寄存器</th><th>功能</th><th>函数调用时</th><th>保护者</th></tr></thead><tbody><tr><td>eax</td><td>累加器</td><td>作为返回值</td><td>调用者保护</td></tr><tr><td>ebx</td><td>基地址寄存器</td><td>临时参数</td><td>被调用者保护</td></tr><tr><td>ecx</td><td>计数器</td><td>第 4 个参数</td><td>调用者保护</td></tr><tr><td>edx</td><td>中间数据寄存器</td><td>第 3 个参数</td><td>调用者保护</td></tr><tr><td>esi</td><td>源变址寄存器</td><td>第 2 个参数</td><td>被调用者保护</td></tr><tr><td>edi</td><td>目标变址寄存器</td><td>第 1 个参数</td><td>被调用者保护</td></tr><tr><td>ebp</td><td>栈底指针</td><td>-</td><td>被调用者保存</td></tr><tr><td>esp</td><td>栈顶指针</td><td>-</td><td>-</td></tr></tbody></table><p>注：在 main 函数中调用函数 add ，main 为调用者，add 为被调用者。</p><p>在 main 函数调用 add 之前，应该将【EAX, ECX, EDX】保存到栈中。</p><p>在 add 函数中应该将【EBX, ESI, EDI, EBP】保存到栈中，在函数执行完成后，恢复原始数据。</p><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><p>在 x86 指令中，包括三类操作数：立即数、寄存器和存储器引用。</p><p><strong>立即数</strong>：即常数，任何可以用 32 位寄存器表示的数，都可以作为立即数。</p><p>立即数使用前缀<code>$</code>进行表示，后面可跟十进制或者十六进制。使用 $I_{mm}$ 代表任意立即数。<br>例如：<code>$0x10</code> 或者 <code>$16</code> ，都表示数字 16。</p><p><strong>寄存器</strong>：用符号 $E_a$ 表示任意寄存器 a , 使用 $R[E_a]$ 表示寄存器 a 的值。</p><p><strong>存储器引用</strong>：存储器引用表示存储器某个地址的数据。<br>用 $M[Addr]$ 表示地址 Addr 的值。</p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>x86 包括 7 种寻址方式，分别为：_立即数寻址_、_寄存器寻址_、_绝对寻址_、_间接寻址_、_基址+偏移寻址_、_变址寻址_、_比例变址寻址_。</p><p>前三种寻址方式的表示即上面立即数的表示方式。</p><p><strong>间接寻址</strong>：通过访问寄存器 $E_a$ 的值($R[E_a]$)，访问对应地址的值。<br>使用符号 $M[R[E_a]]$ 表示。</p><p>例如：<code>EAX</code> 寄存器为 <code>0x0001</code> ，地址 <code>0x0001</code> 的值为<code>0x1234</code>。<br>则 $M[R[E_{eax}]]$ 的值为<code>0x1234</code></p><p><strong>基址+偏移寻址</strong>：通过寄存器 $E_a$ 和立即数 $I_{mm}$ ，访问地址：$R[E_a]+I_{MM}$ 处的值。<br>使用符号 $M[I_{MM}+R[E_a]]$ 表示。</p><p>完整寻址方式见下表：</p><p>类型 |AT&amp;T 语法格式| 操作数值| 名称|<br>|—|—|—|—|—|<br>|立即数| $$Imm$ |$Imm$ |立即数寻址|<br>|寄存器| $E_a$| $R[E_a]$ |寄存器寻址|<br>|存储器| $Imm$| $M[Imm]$ |绝对寻址|<br>|存储器| $(E_a)$| $M[R[E_a]] $|间接寻址|<br>|存储器| $Imm(E_b)$| $M[Imm+R[E_b]]$ |（基址+偏移量）寻址|<br>|存储器| $(E_b,E_i)$| $M[R[E_b]+R[E_i]]$ |变址寻址|<br>|存储器| $Imm(E_b,E_i)$|$ M[Imm+R[E_b]+R[E_i]]$ |变址寻址|<br>|存储器| $(,E_i,s)$ |$M[R[E_i]*s]$ |比例变址寻址|<br>|存储器| $Imm(,E_i,s)$| $M[Imm+R[E_i]*s]$ |比例变址寻址|<br>|存储器| $(E_b,E_i,s)$| $M[R[E_b]+R[E_i]*s] $|比例变址寻址|<br>|存储器| $Imm(E_b,E_i,s)$| $M[Imm+R[E_b]+R[E_i]*s]$ |比例变址寻址|</p><p>立即数 $Imm$、基址寄存器 $E_b$、变址寄存器 $E_i$、比例因子 $s$（其值为 1、2、4、8）。</p><p><a href="https://www.cnblogs.com/sgawscd/p/11210026.html" title="x86-64数据格式、通用寄存器与操作数格式"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gcov查看代码覆盖率</title>
    <link href="/2022/09/04/gcov%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <url>/2022/09/04/gcov%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>絮絮叨叨：想写的素材有很多，每次都是拖到最后也没写完，还是要多学习彭同学的 “先找软柿子捏” 。</p><h2 id="GCOV-工具简介"><a href="#GCOV-工具简介" class="headerlink" title="GCOV 工具简介"></a>GCOV 工具简介</h2><p>gcov是一个测试代码覆盖率的工具。</p><p>它是 gcc 自带的查看代码覆盖率的工具，无需额外安装，在嵌入式的 arm-eabi-none-gcc 中同样可以使用（需要重写部分系统函数）。</p><p>使用效果如下图所示：</p><p><img src="https://files.mdnice.com/user/11205/d11860cd-1d41-4dca-80f5-bc404c9bc55f.png"></p><p>程序运行完成后，可以查看每个文件的代码覆盖率情况，上面报告中展示了每个文件的行覆盖率，函数覆盖率和分支覆盖率。</p><p>打开一个文件的覆盖率报告，页面对开始有文件的基本信息描述，以 FreeRTOS 的 task.c 为例，它的有效代码行数为 921 行，共 24 个函数（几千行的文件其实也没多少嘛～）</p><p><img src="https://files.mdnice.com/user/11205/05cb15c2-f805-4272-9ed1-d3851373f7bd.png"></p><p><img src="https://files.mdnice.com/user/11205/0979d607-cc67-42a1-9dee-74f777f7bfde.png"></p><p>在覆盖率的正文，有该文件的完整代码，并用不同颜色进行高亮标注了：</p><ul><li>蓝色表示运行被覆盖的代码，前面的数字表示代码执行次数。</li><li>红色表示未执行代码。</li><li>白色表示无效代码，包括注释，空行和未编译代码。</li></ul><h2 id="gcov-使用"><a href="#gcov-使用" class="headerlink" title="gcov 使用"></a>gcov 使用</h2><p>使用 gcov 的流程非常简单，只需要三步即可。<br>下面以 hello world 为例，展示生成覆盖率报告。</p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//main.c</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>第一步：</strong> 添加编译参数 <code>-fprofile-arcs -ftest-coverage</code></p><p>在所需要的生产覆盖率的文件中，添加编译参数，编译代码生成目标文件，同时会生成 *.gcno 文件，其中包含文件的行号等信息。</p><div class="code-wrapper"><pre><code class="hljs sh">gcc main.c -c -fprofile-arcs -ftest-coverage -o main.o<span class="hljs-built_in">ls</span> <span class="hljs-comment"># 输出文件列表:</span><span class="hljs-comment"># main.c  main.gcno  main.o</span>gcc main.o -lgcov -o main</code></pre></div><p><strong>第二步:</strong> 添加链接参数 <code>-lgcov</code> ，运行程序</p><p>运行程序后，会生成一个 *.gcda 文件，里面包含代码执行次数等数据。</p><div class="code-wrapper"><pre><code class="hljs sh">gcc main.o -lgcov -o main<span class="hljs-comment"># 运行程序</span>./main<span class="hljs-comment"># hello world</span><span class="hljs-built_in">ls</span> <span class="hljs-comment"># 输出文件列表:</span><span class="hljs-comment">#main  main.c  main.gcda  main.gcno  main.o</span></code></pre></div><p><strong>第三步:</strong> 输出覆盖率报告<br>使用下面命令输出覆盖率报告</p><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 第一次使用前安装工具</span>sudo apt install lcov<span class="hljs-comment"># 生成覆盖率文本报告</span>lcov -c -d . -o test.info --rc lcov_branch_coverage=1<span class="hljs-comment"># 生成覆盖率网页报告</span>genhtml --branch-coverage -o result test.info</code></pre></div><p>输入上面两&#x2F;三条命令后在，执行命令的文件路径可以看到一个 result 文件夹，在里面就是对应的网页覆盖率报告。</p><p><img src="https://files.mdnice.com/user/11205/bfb34f39-e377-4100-917a-778181ce61bc.png"><br>用浏览器打开 index.html 就可以看到最开始展示的覆盖率信息了。</p><h2 id="特殊环境使用注意点："><a href="#特殊环境使用注意点：" class="headerlink" title="特殊环境使用注意点："></a>特殊环境使用注意点：</h2><p>在正常使用 gcov 是非常简单的，但是在特殊项目中使用 gcov 需要注意一些坑，否则就会跟我一样掉进去出不来。。。</p><ol><li><p>链接时，会在 .init_array 段插入 __gcov_init() 函数，该函数在 main 运行之前初始化 gcov 运行环境。</p><p>如果修改过链接脚本，注意 .init_array 的全局构造函数是否执行成功。</p></li><li><p>和上面一样，链接时，会在全局析构函数中插入 __gcov_exit() 函数，在 main 执行结束后，输出 *.gcda 文件。</p><p>如果程序为异常退出，则不会生成 *.gcda 文件，此时需要在代码适当位置插入 __gcov_flush() 函数，将文件进行保存。</p></li><li><p>默认状态 *.gcda 文件和 *.gcno 文件所在文件夹相同，如果需要修改输出文件夹，可通过添加环境变量：GCOV_PREFIX 和 GCOV_PREFIX_STRIP</p><p>GCOV_PREFIX_STRIP&#x3D;16 ， 为将原有路径裁剪16个文件夹。<br>GCOV_PREFIX&#x3D;&#x2F;home&#x2F;tester&#x2F;build ， 为将裁剪后的路径添加前缀<br>例如：上文中默认 main.gcda 所在的文件 &#x2F;home&#x2F;tester&#x2F;main.gcda，裁剪后添加前缀后变为&#x2F;home&#x2F;tester&#x2F;build&#x2F;main.gcda</p></li><li><p>gcov 内部使用了一些系统函数，需要确保这些哈是函数可用</p></li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>gcov 实现基本原理为在编译时，向代码中插桩，记录运行时的执行流，具体细节可见参考链接两位大佬的详细分析，我就在在此赘述了。</p><p><a href="%22https://blog.csdn.net/livelylittlefish/article/details/6321909%22" title="Linux平台代码覆盖率测试工具GCOV相关文件分析">1</a></p><p><a href="%22https://blog.csdn.net/livelylittlefish/article/details/6448867%22" title="gcov代码分析gcovdump原理分析">2</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mktemp 使用需谨慎，认真对待编译器警告</title>
    <link href="/2022/09/04/mktemp%20%E4%BD%BF%E7%94%A8%E9%9C%80%E8%B0%A8%E6%85%8E%EF%BC%8C%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85%E7%BC%96%E8%AF%91%E5%99%A8%E8%AD%A6%E5%91%8A/"/>
    <url>/2022/09/04/mktemp%20%E4%BD%BF%E7%94%A8%E9%9C%80%E8%B0%A8%E6%85%8E%EF%BC%8C%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85%E7%BC%96%E8%AF%91%E5%99%A8%E8%AD%A6%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="mktemp-使用需谨慎，认真对待编译器警告"><a href="#mktemp-使用需谨慎，认真对待编译器警告" class="headerlink" title="mktemp 使用需谨慎，认真对待编译器警告"></a>mktemp 使用需谨慎，认真对待编译器警告</h1><p>絮絮叨叨：今天在做一个文件缓存管理的时候，使用 mktemp 生成一个临时文件名，在编译时编译器提示我，该函数不安全，头铁的我还是使用了。</p><p><img src="https://files.mdnice.com/user/11205/99f31186-240b-4c10-97a9-93e82d81fdb4.png"></p><p>然后我就变成这样了</p><p><img src="https://files.mdnice.com/user/11205/473458a9-52ad-4ebf-953a-7911acdfd132.png"></p><h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><p>mktemp 的作用是根据传入的字符串模板，生成一个临时文件名。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">char</span> path[PATH_MAX] = <span class="hljs-string">&quot;test_XXXXXX&quot;</span>;temp_tath = mktemp(path);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;path:%s\n&quot;</span>, temp_tath);<span class="hljs-comment">// 输出 test_ZjSxUe</span></code></pre></div><p>这段代码时简单的复现了一下当时的场景，看看你能发现其中的 bug 不~</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">char</span> path[PATH_MAX] = <span class="hljs-string">&quot;test_XXXXXX&quot;</span>;    <span class="hljs-type">char</span> *temp_tath;    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;        temp_tath = mktemp(path);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;path:%s\n&quot;</span>, temp_tath);    &#125;&#125;<span class="hljs-comment">// 预期结果：</span>path:test_hMLBpqpath:test_Ig8q7ppath:test_Xs1OTp<span class="hljs-comment">// 实际结果：</span>path:test_tEb4Mtpath:path:</code></pre></div><p>如果你是第一次使用这个函数，又没有好好看文档的话，很可能会掉进坑里面去。。</p><h2 id="mktemp-正确用法"><a href="#mktemp-正确用法" class="headerlink" title="mktemp 正确用法"></a>mktemp 正确用法</h2><p>这是 man 手册中关于 mktemp 使用的介绍。</p><p><img src="https://files.mdnice.com/user/11205/78bc282f-1dae-4017-8499-b2ba8a54e97a.png"></p><p>大概意思为：<br>mktemp 使用时传入最后六个字符为 <code>XXXXXX</code> 的模板字符串 ，它就会将最后六个字符替换，以生成唯一的文件名。</p><p>mktemp 的返回值为总是为传入的模板字符串，在输入格式错误时，将会把模板字符串清空（空字符串）。</p><hr><p>如果把 man 手册所说的几点看明白的话，出现上面的原因也就很好解释了：</p><ol><li><code>mktemp</code> 返回的是被修改后的模板字符串指针</li><li>当 <code>mktemp</code> 输入的模板字符串格式不正确时，将清空模板字符串，而不是返回一个空指针（我就是这么理解的🤦‍♂️）</li></ol><p>所以正确的使用方法是：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">char</span> path[PATH_MAX] ;    <span class="hljs-type">char</span> *temp_tath;    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-built_in">strcpy</span>(path, <span class="hljs-string">&quot;test_XXXXXX&quot;</span>);        temp_tath = mktemp(path);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;path:%s\n&quot;</span>, temp_tath);    &#125;&#125;</code></pre></div><h2 id="不安全原因"><a href="#不安全原因" class="headerlink" title="不安全原因"></a>不安全原因</h2><p>在我定位到问题原因后以为这么就是编译器提示不安全的原因，但是在看完文档后才知道这只是我用法出错了。</p><p>在 man 手册中对于不安全原因的描述为：</p><p><img src="https://files.mdnice.com/user/11205/04e22f70-b16c-4e11-b9da-fb58cf0269fa.png"></p><p>大概意思是：<code>mktemp</code> 实现时使用进程ID和单个字母组成，所以最多只有26种不同的名字。这种名字很容易被猜到，而且在测试文件名是否存在时，可能会与已经打开的文件产生竞争。</p><p>所以以后在使用新的函数或者接口时，要多看看官方文档啊！</p><p>这应该不是第一次，也不太可能是最后一次，只是提醒自己<strong>慢即是快</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32L0使用arduino</title>
    <link href="/2022/09/04/stm32L0%E4%BD%BF%E7%94%A8arduino/"/>
    <url>/2022/09/04/stm32L0%E4%BD%BF%E7%94%A8arduino/</url>
    
    <content type="html"><![CDATA[<p><strong>絮絮叨叨：</strong><br>在做一个无线姿态传感器的小项目时，看中了 arduino 强大的第三方库，于是选型使用了 arduino 进行开发。<br>可是在第一步时就踩坑了。。。。</p><h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>我硬件使用 STM32L051K8U6 + NRF24L01 + MPU6050，准备用来做一个无线的姿态传感器。</p><p><img src="https://files.mdnice.com/user/11205/dd0c5e9b-d36c-41b6-bc84-76dee21a7a33.png"></p><p>在使用 arduino 对 stm32 时，烧录的 Demo 程序没有任何反应，而使用之前 keil 编译的程序则可以正常运行。</p><p>在简化程序后，发现 LED 可以正常运行，但是串口不能工作。于是开始排查问题</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>在我使用 STM32F103C8T6 烧录相同的 Demo 程序后，可以正常运行。于是问题被锁定在 STM32L051 上。</p><h3 id="串口波特率异常"><a href="#串口波特率异常" class="headerlink" title="串口波特率异常"></a>串口波特率异常</h3><p>在测试时，发现 L051 的板子，LED 可以运行，但是串口不能接受数据，于是首先怀疑波特率是否正确。但是手头暂时没有逻辑分析仪，只能通过软件测试。</p><p>使用 Keil 配置工程测试，串口 TX、RX 接线正常，芯片功能正常。由于我使用内部时钟源，而 F103 板子使用外部晶振，于是开始确认系统时钟频率是否正确。</p><p>好在 arduino 中可以直接使用 HAL 库的函数, 调用 <code>HAL_RCC_GetSysClockFreq</code> 函数读取判断系统时钟。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED PB3</span><span class="hljs-type">int</span> ms = <span class="hljs-number">200</span>;<span class="hljs-type">uint32_t</span> sysclock = <span class="hljs-number">0</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;  sysclock = HAL_RCC_GetSysClockFreq();  <span class="hljs-keyword">if</span> (sysclock == <span class="hljs-number">32000000</span>)&#123;    ms = <span class="hljs-number">1000</span>;  &#125;  pinMode(LED, OUTPUT);  Serial.begin(<span class="hljs-number">115200</span>);  Serial.println(<span class="hljs-string">&quot;system init\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;  digitalWrite(LED, HIGH);  delay(ms);  digitalWrite(LED, LOW);  delay(ms);&#125;</code></pre></div><p>经过测试，芯片的时钟配置也是正常，此路不通。。</p><h3 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h3><p>在检查时钟正常后，开始怀疑串口配置是否正常。于是修改默认串口 <code>Serial</code> 为 <code>Serial1</code> 编译失败，提示未定义引用。<br><img src="https://files.mdnice.com/user/11205/481e6f34-1ce9-4a64-a220-2a27685848bc.png"></p><p>修改为 <code>Serial2</code> ，串口同样无输出。。。</p><p>既然可以使用 HAL 库进行配置，那就使用 HAL 库初始化串口，进行测试，失败。。。</p><p>在使用 HAL 库配置完串口后顺手使用 HAL 库的串口发送函数进行测试。</p><p><code>HAL_UART_Transmit(&amp;huart1, (uint8_t *)&quot;hello\n&quot;, 6, 1000 );</code></p><p>竟然可以用？！！！</p><h3 id="arduino-移植调试"><a href="#arduino-移植调试" class="headerlink" title="arduino 移植调试"></a>arduino 移植调试</h3><p>于是问题确认在 arduino 内部的代码中，奈何在 arduino 中无法进行调试，于是尝试将 arduino 的代码移植到 makefile 中编译，方便进行调试。</p><p>不过之前也移植过，这个好说，然后开始各种折腾，离初始目标越来越远。。。</p><p>在移植 arduino 到 makefile 的过程中，想到查看一下符号表，只需要把用到的文件进行编译调试即可。</p><p>于是 objdump 查看了一下，在查看符号表的时候发现一个奇怪的问题，引起我的注意：</p><p><img src="https://files.mdnice.com/user/11205/95855b17-4291-4da4-9f2f-df8f8a1fd927.png"></p><p>在符号表中出现的怎么都是 <code>Serial</code>2 的配置，没有关于 &#96;&#96;&#96;&#96;&#96;&#96;Serial<code>1</code> 的初始化，所以 <code>Serial</code> 的宏是指向 <code>Serial</code>2 ?</p><p>于是查看了一下 variant 中 IO 的配置，不看不知道，一看吓一跳。。。。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// UART Definitions</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SERIAL_UART_INSTANCE</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL_UART_INSTANCE  2</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">// Default pin used for generic &#x27;```Serial```&#x27; instance</span><span class="hljs-comment">// Mandatory for Firmata</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PIN_SERIAL_RX</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> PIN_SERIAL_RX         PA3</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PIN_SERIAL_TX</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> PIN_SERIAL_TX         PA2</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>在配置文件中赤裸裸的使用着串口2 🤦‍♂️</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>找到问题后，就很好解决了。既然 <code>Serial</code> 使用的是 <code>Serial2</code> ，那我初始化 <code>Serial1</code> 然后将这个宏重新定义到 <code>Serial1</code> 不就解决问题了。</p><p>上面的代码变为：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">undef</span> Serial</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> Serial Serial1</span>HardwareSerial <span class="hljs-title function_">Serial</span><span class="hljs-params">(USART1)</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> LED PB3</span><span class="hljs-type">int</span> ms = <span class="hljs-number">200</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;  pinMode(LED, OUTPUT);  Serial.begin(<span class="hljs-number">115200</span>);  Serial.println(<span class="hljs-string">&quot;system init&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;  digitalWrite(LED, HIGH);  delay(ms);  digitalWrite(LED, LOW);  delay(ms);&#125;</code></pre></div><p>下载运行，完美解决~</p><h2 id="复盘分析"><a href="#复盘分析" class="headerlink" title="复盘分析"></a>复盘分析</h2><p>其实在最开始在怀疑串口配置的时候，已经想到了是否是串口号配置不对，而且编译报错信息已经提示了 <code>Serial1</code> 未定义，只是在当时未引起注意。</p><p>在经过一番折腾后，发现还是串口号配置错误导致的。</p><p><strong>在 debug 的过程中应该本着 “大胆假设，小心求证” 的心态去排查问题。</strong></p><p>虽然分析问题时想到这个原因，但是在求证的过程中却忽略了这个重要信息，导致后面走了不少弯路。</p><p>如果这是一个复杂代码的 debug , 同样不能运行调试，那问题应该怎么被发现解决呢？</p><p>这种情况在之前 debug 时已经碰到过了，最后的结果是花费大量时间和精力，最后发现问题原因早被猜想中了，只是在验证时被忽略一些细节而放过。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32使用系统IO</title>
    <link href="/2022/09/04/stm32%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9FIO/"/>
    <url>/2022/09/04/stm32%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9FIO/</url>
    
    <content type="html"><![CDATA[<h2 id="系统-IO-和标准-IO"><a href="#系统-IO-和标准-IO" class="headerlink" title="系统 IO 和标准 IO"></a>系统 IO 和标准 IO</h2><p><strong>系统 IO</strong> 一般指的是 Linux&#x2F;Unix 系统调用中关于 I&#x2F;O 操作的统称，其中包括 open、read、write、close 等操作。<br>与系统 IO 对应还有标准 IO，标准 IO 是 ISO 标准中 C 语言标准定义的 IO 访问接口，例如 fprintf&#x2F;fgets 等 C 语言标准中定义的文件访问接口。</p><p>在 Linux 系统中 open&#x2F;read&#x2F;write 等函数的底层实现是通过系统调用访问的，在 STM32 的裸机中没有操作系统，更没有这些系统调用。<br>但是我们可以用一种其他的方式去实现这些系统 IO，而不需要操作系统。</p><h2 id="半主机模式重写文件访问接口"><a href="#半主机模式重写文件访问接口" class="headerlink" title="半主机模式重写文件访问接口"></a>半主机模式重写文件访问接口</h2><p>这个方法其实就是利用半主机模式，去重写系统库中关于半主机接口中关于文件访问接口的底层 **”弱定义”**。</p><p>这个听上去好像听陌生的，其实很多人都使用过，就是最简单的 <a href="https://mp.weixin.qq.com/s?__biz=MzUxNzY5MTAzMA==&mid=2247483744&idx=1&sn=32b7b19b4542ce0ae8287bc8790bbc46&chksm=f9950299cee28b8f3751a29b8fcbb0b398e3e6a46da8478ec3eae86aee268e03a9ee842f8bf4#rd">printf 重定向</a>。</p><p>在 GCC 重定向 printf 到串口使用了如下代码:</p><div class="code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> _write(<span class="hljs-built_in">int</span> fd, <span class="hljs-built_in">char</span> * ptr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>)&#123;  HAL_UART_Transmit(&amp;huart1, (uint8_t *) ptr, <span class="hljs-built_in">len</span>, HAL_MAX_DELAY);  return <span class="hljs-built_in">len</span>;&#125;</code></pre></div><p>这个就是在半主机模式下重写了 write 函数的底层接口，当系统调用 printf 函数时最终会调到 _write 函数向串口写入数据。</p><p>在 ARM 关于<a href="https://developer.arm.com/documentation/dui0471/g/Semihosting" title="半主机模式介绍">主机模式的文档</a>中，<em>Direct semihosting C library function dependencies</em>  一节提供了可重写的系统 IO 的底层函数。<br><img src="https://files.mdnice.com/user/11205/4ccf68a7-1733-4803-b9cd-5f5d94fbac65.png"></p><p>通过重写上述列表中的函数，即可通过调用 C 库 <strong>系统 IO</strong> 访问。</p><h2 id="构建文件系统"><a href="#构建文件系统" class="headerlink" title="构建文件系统"></a>构建文件系统</h2><p>在上面介绍使用系统 IO 的基本原理：通过重写 _open&#x2F;_write&#x2F;_read 等接口，即可通过 open&#x2F;write&#x2F;read 接口访问。</p><p>但是以上只提供了一系列系统接口，并将其与标准 IO 绑定，可以使用 open&#x2F;fopen 等函数进行访问，但是具体访问的数据依旧需要自己进行实现。</p><p>在这次测试中我选用了 LittleFS 作为文件系统，使用 RAM 中预分配的全局变量作为存储介质，构建了一个基于内存的文件系统。（开发板没有 Flash  先用 RAM 代替了。。。）</p><p>其 _open 函数如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件描述符列表，不包括标准输入输出, 最大 fd 为 FS_FILE_MAX + 3</span><span class="hljs-type">lfs_file_t</span> *g_file_list[FS_FILE_MAX] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> _open(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> flags)&#123;  <span class="hljs-type">int</span> i;  <span class="hljs-type">int</span> i_flags = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> ((flags &amp; O_CREAT)  == O_CREAT)  i_flags |= LFS_O_CREAT;  <span class="hljs-keyword">if</span> ((flags &amp; O_RDONLY) == O_RDONLY) i_flags |= LFS_O_RDONLY;  <span class="hljs-keyword">if</span> ((flags &amp; O_WRONLY) == O_WRONLY) i_flags |= LFS_O_WRONLY;  <span class="hljs-keyword">if</span> ((flags &amp; O_RDWR)   == O_RDWR)   i_flags |= LFS_O_RDWR;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FS_FILE_MAX; i++)  &#123;    <span class="hljs-keyword">if</span> (g_file_list[i] == <span class="hljs-literal">NULL</span>)    &#123;      g_file_list[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">lfs_file_t</span>));      <span class="hljs-built_in">lfs_file_open</span>(&amp;g_lfs, g_file_list[i], name, i_flags);      <span class="hljs-keyword">return</span> i + <span class="hljs-number">3</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre></div><p>其基本逻辑时将 open 传入的参数转换为 lfs_file_open 使用的参数，传入 lfs_file_oen, 然后分配一个空闲的文件描述符作为返回值。</p><p>在 _read 和 _write 接口中对文件描述符进行判断，当文件描述符为 0&#x2F;1&#x2F;2 时将数据重定向到串口，否则从文件中读写数据。<br>代码如下：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> _write(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *pBuffer, <span class="hljs-type">int</span> size)&#123;  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">1</span> || fd ==<span class="hljs-number">2</span>)  &#123;    <span class="hljs-built_in">HAL_UART_Transmit</span>(&amp;huart3, (<span class="hljs-type">uint8_t</span> *)pBuffer, size, size);  &#125;  <span class="hljs-keyword">else</span>  &#123;    res = <span class="hljs-built_in">lfs_file_write</span>(&amp;g_lfs, g_file_list[fd], pBuffer, size);  &#125;  <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><p>完成以上步骤后，便可以在程序中使用 open&#x2F;read&#x2F;write 等接口访问文件系统了，测试程序如下：</p><div class="code-wrapper"><pre><code class="hljs lisp">fs_init()<span class="hljs-comment">;</span>write(<span class="hljs-name">STDOUT_FILENO</span>, <span class="hljs-string">&quot;system init ...\n&quot;</span>, <span class="hljs-number">17</span>)<span class="hljs-comment">;</span>mkdir(<span class="hljs-string">&quot;/data&quot;</span>, <span class="hljs-number">0755</span>)<span class="hljs-comment">;</span>fd = open(<span class="hljs-string">&quot;/data/ascii.txt&quot;</span>, O_CREAT|O_WRONLY)<span class="hljs-comment">;</span>for (<span class="hljs-name">ch</span> = <span class="hljs-number">32</span><span class="hljs-comment">; ch &lt; 126; ch++)</span>&#123;  write(<span class="hljs-name">fd</span>, <span class="hljs-symbol">&amp;ch</span>, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>&#125;close(<span class="hljs-name">fd</span>)<span class="hljs-comment">;</span>fd = open(<span class="hljs-string">&quot;/data/ascii.txt&quot;</span>, O_RDONLY)<span class="hljs-comment">;</span>while (<span class="hljs-number">1</span>)&#123;  char buff[<span class="hljs-number">16</span>]<span class="hljs-comment">;</span>  int res = read(<span class="hljs-name">fd</span>, buff, <span class="hljs-number">16</span>)<span class="hljs-comment">;</span>  if (<span class="hljs-name">res</span> &lt; <span class="hljs-number">0</span>)  &#123;    close(<span class="hljs-name">fd</span>)<span class="hljs-comment">;</span>    break<span class="hljs-comment">;</span>  &#125;  printf(<span class="hljs-string">&quot;system tick: %&quot;</span>PRIu32<span class="hljs-string">&quot;\n&quot;</span>, HAL_GetTick())<span class="hljs-comment">;</span>  printf(<span class="hljs-string">&quot;read file data:%.*s\n&quot;</span>, <span class="hljs-number">16</span>, buff)<span class="hljs-comment">;</span>  HAL_Delay(<span class="hljs-number">500</span>)<span class="hljs-comment">;</span>&#125;</code></pre></div><p>程序下载烧录后，使用串口工具查看到一下数据：<br><img src="https://files.mdnice.com/user/11205/a8ac947d-0eca-462d-9e6a-5cddfedc6cfe.png"></p><h2 id="移植的用途"><a href="#移植的用途" class="headerlink" title="移植的用途"></a>移植的用途</h2><p>关于在 STM32 中使用系统 IO 的尝试，主要是为了在 STM32 上移植一些 Linux 下的第三方库。</p><p>他们很多都不可避免的使用了文件 IO 和 Posix 线程接口，对于 Posix 线程的接口在 FreeRTOS 中有提供，但是系统 IO 却没有找到什么合适的方案，于是有了这样的一种尝试。</p><p>现在好像已经有了更好的方案而不用去移植，不过使用这种方式的好处是以较少的代码可以将系统 IO 和标准 IO 进行关联。</p><h2 id="关于半主机模式"><a href="#关于半主机模式" class="headerlink" title="关于半主机模式"></a>关于半主机模式</h2><p>最后提一下半主机模式：这个实质上是提供了一个在调试时访问主机数据的方法：</p><p>通过触发 SVC 指令，在 R0 寄存器中传入需要的系统调用 ID, 在 R1 寄存器中传入参数结构体的指针。</p><p>通过调试器，可以在主机接受到对应的系统调用，并进行相应的处理。</p><p><a href="https://bbs.pediy.com/thread-266324.htm" title="qemu 中使用半主机模式"> </a></p><p><a href="https://developer.arm.com/documentation/dui0475/g/the-arm-c-and-c---libraries/direct-semihosting-c-library-function-dependencies?lang=en" title="依赖半主机接口的函数"> </a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么建议少用if语句，不是运行效率</title>
    <link href="/2022/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%B0%91%E7%94%A8if%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%8D%E6%98%AF%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    <url>/2022/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%B0%91%E7%94%A8if%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%8D%E6%98%AF%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么建议少用if语句，不是影响运行效率！"><a href="#为什么建议少用if语句，不是影响运行效率！" class="headerlink" title="为什么建议少用if语句，不是影响运行效率！"></a>为什么建议少用if语句，不是影响运行效率！</h1><p><strong>絮絮叨叨</strong>：放假使我的作息混乱…</p><hr><p>相信大家或多或少的听说过，少用点if-else吧？但是为什么要少用呢，有人说他会影响程序运行效率，但是这并不是他最大的罪状！</p><h2 id="if-else-的罪状"><a href="#if-else-的罪状" class="headerlink" title="if-else 的罪状"></a>if-else 的罪状</h2><p>if-else 作为三种最基本的程序结构之一，是我们从最开始学习编程时就接触的基本语句。但是到后面的阶段就不断听人说少用if-else。</p><p>如果询问原因的话，你得到的结果大概率时if-else导致程序运行效率下降。这次来扯扯为什么我们说要少用if-else。</p><ul><li>导致程序运行效率下降（大部分时候可以忽略）</li><li>破坏程序结构，导致代码难以维护（核心原因 ⭐）</li></ul><h2 id="if-语句与运行效率"><a href="#if-语句与运行效率" class="headerlink" title="if 语句与运行效率"></a>if 语句与运行效率</h2><p>说起if语句导致程序运行效率下降，就不得不提到CPU的流水线结构，效率降低主要是由于多级流水线结构造成的。</p><p>现代的大部分CPU在执行代码的时候并不是读取一条指令然后执行一条执行的,而是使用了一种叫做流水线技术的方式，同时去执行多个操作。</p><h3 id="流水线的影响"><a href="#流水线的影响" class="headerlink" title="流水线的影响"></a>流水线的影响</h3><p>比如三级流水线就是指，CPU在执行一条指令时，同时会读取后面的指令，并对进行译码。（读取、译码、执行）<br><img src="https://files.mdnice.com/user/11205/8089e177-ca18-4758-bb6f-d6d289700cbc.png"></p><p>这样处理的优势很明显，使用流水线技术可以大大的提高执行效率。</p><p>但是它并不是所有时刻有效的，在程序中执行跳转代码时，CPU 会丢弃流水线现有的结果。<br>原因嘛，很简单！我都不执行后面的代码了，你提前读取有啥用~</p><p>所以在这个时候if语句相对于顺序执行的指令，会有几个时钟周期的差距。但这不是if语句说特有的，所有带跳转结构的语句都会这样(if、switch、for)。</p><h3 id="分支预测的影响"><a href="#分支预测的影响" class="headerlink" title="分支预测的影响"></a>分支预测的影响</h3><p>多级流水线在遇到跳转时，会有几个时钟的周期的影响，但这并不是它被指控运行效率低的主要原因。<br>而是在因为它分支预测部分，它有可能有10-20个时钟周期的影响，在大量使用if的地方这种影响将被放大。</p><p>下面说说分支预测为什么会有这么大的影响。</p><p>在上面说到多级流水在遇到跳转指令时会清空当前流水线，CPU的设计者在设计引入了一种叫做分支预测的技术来进行处理这个问题。<br>分支预测简单说就是猜测后面的程序会执行那一段代码，并提前将它读取。</p><p><img src="https://files.mdnice.com/user/11205/fdeb3e5f-33eb-4f72-b8ff-df43154169ea.png"><br>例如一辆火车，在有很多岔道的路上前进，为了不让他每次都在岔道停下等待（清空流水线），于是想出了一个办法。<br>猜测火车需要前进的方向，如果猜中了火车就可以不用停下等待，而提高效率。<br>但是如果猜错了，则需要倒车回到岔路口重新选择。这样的错误代价就比较高了。</p><p>而大家所说的效率降低主要源于此。</p><h2 id="if-else-对程序结构的影响"><a href="#if-else-对程序结构的影响" class="headerlink" title="if-else 对程序结构的影响"></a>if-else 对程序结构的影响</h2><p>在大部分情况下，我们是不需要考虑if语句对代码执行效率的影响，我们甚至感觉不到它的存在。<br>因为大部分情况下，CPU的性能是足够的（性能优化时除外）。</p><p>但是if-else对程序结构的影响却是不容忽视的，因为我们可以直观的感受到它的存在，而且对开发和维护有极大的影响。</p><p>看下面一段代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (condition1==<span class="hljs-literal">true</span>)    &#123;f1();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2==<span class="hljs-literal">true</span>)    &#123;f2();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition3==<span class="hljs-literal">true</span>)    &#123;f3();&#125;</code></pre></div><p>这个代码非常简单：判断不同条件时执行不同的代码块。<br>这段代码写完测试时发现有点问题</p><ol><li>condition1和condition3同时满足时应该先执行f4</li><li>condition3和condition4满足任意一个时执行f3<br>修改代码测试通过后，于是乎代码变成了下面的模样：<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition1==<span class="hljs-literal">true</span>)&#123;  <span class="hljs-keyword">if</span> (condition3==<span class="hljs-literal">true</span>)  &#123; f4(); &#125;  f1();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2==<span class="hljs-literal">true</span>)    &#123; f2(); &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition3==<span class="hljs-literal">true</span> || condition4==<span class="hljs-literal">true</span>)    &#123; f3(); &#125;</code></pre></div>这只是我简单模拟的一段代码，对于稍微复杂的逻辑，if-else的数量远远大于上面的数量。</li></ol><p>在这样的代码中，如果各种condition都是使用flag变量进行标记时，将会是一种巨大的灾难。</p><p>我之前碰到这样的代码时，心情只能用下图表示。</p><p><img src="https://files.mdnice.com/user/11205/dee9a880-1c9d-4e0c-aa44-ba7068afd7e2.png"></p><p>大量使用if-else，会使代码变得难以理解，同时增加后期开发和维护的成本。</p><p>这个才是少用if-else真的原因！</p><h2 id="如何消除if-else"><a href="#如何消除if-else" class="headerlink" title="如何消除if-else"></a>如何消除if-else</h2><p>既然上面说到了if-else有这么多的问题，那应该怎样减少使用它呢，</p><h3 id="1-巧妙使用算术表达式"><a href="#1-巧妙使用算术表达式" class="headerlink" title="1. 巧妙使用算术表达式"></a>1. 巧妙使用算术表达式</h3><p>比如下面的代码，在num不能被5整除时，num加一</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(num%<span class="hljs-number">5</span>&gt;<span class="hljs-number">0</span>)&#123;  num++;&#125;</code></pre></div><p>可以替换成 <code>num  = num + !!(num%5);</code></p><p>这种一般是在对计算结果进行简单判断时可是使用，它的优化点在于消除了分支结构，提高了执行效率。（虽然说很小）。</p><h3 id="使用断言（assert）"><a href="#使用断言（assert）" class="headerlink" title="使用断言（assert）"></a>使用断言（assert）</h3><p>在对函数参数进行合法性检查时常用，可以减少大量对参数进行时的if-else，适用场景也比较简单。</p><h3 id="查找表（函数转移表）"><a href="#查找表（函数转移表）" class="headerlink" title="查找表（函数转移表）"></a>查找表（函数转移表）</h3><p>查找表或者函数转移表，可以对程序的整体结构进行优化或者改进。<br>比如下面一个计算器的代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(oper == ADD)&#123; Result=add(op1,op2);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper == SUB)&#123; Result=add(op1,op2);&#125;<span class="hljs-keyword">if</span>(oper == MUL)&#123; Result=mul(op1,op2);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper == DIV)&#123; Result=div(op1,op2);&#125;</code></pre></div><p>使用函数转移表可改进为</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*<span class="hljs-type">oper_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<span class="hljs-type">oper_t</span> oper_table[]=&#123;add, sub, mul, div&#125;;...result = oper_table[oper](op1,op2);</code></pre></div><p>查找表则相对更灵活，可以对不同类型的数据进行查找;</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> arrayof(x)  (sizeof(x)/sizeof(x[0]))</span><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*<span class="hljs-type">oper_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">find_table_t</span> &#123;</span>  <span class="hljs-type">char</span> *oper_name;  <span class="hljs-type">oper_t</span> oper_func;&#125;<span class="hljs-type">find_table_t</span> oper_table[]=&#123;&#123;<span class="hljs-string">&quot;add&quot;</span>,add&#125;, &#123;<span class="hljs-string">&quot;sub&quot;</span>,sub&#125;, &#123;<span class="hljs-string">&quot;mul&quot;</span>,mul&#125;, &#123;<span class="hljs-string">&quot;div&quot;</span>,div&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arrayof(oper_table);i++)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(oper,oper[i].oper_name)==<span class="hljs-number">0</span>)  &#123;    result = oper[i].func(op1,op2);    <span class="hljs-keyword">return</span> result;  &#125;&#125;</code></pre></div><h3 id="责任链（职责链）"><a href="#责任链（职责链）" class="headerlink" title="责任链（职责链）"></a>责任链（职责链）</h3><p>责任链将一个复杂逻辑的流程进行分解，将每个判断条件的判断交给责任链节点进行处理，在处理完成后将结果传递给下一个节点。</p><p>在后面有专门一篇文章写责任链模式，在这就不展开了。</p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>状态机也是消除if-else的一种方法，在状态机中对所有条件的判断变成的状态转移。</p><p>在后面也会有单独的文章讲解有限状态机的实现和应用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二值信号量和互斥锁有何异同</title>
    <link href="/2022/09/04/%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/"/>
    <url>/2022/09/04/%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="二值信号量和互斥锁有何异同（优先级反转的处理）"><a href="#二值信号量和互斥锁有何异同（优先级反转的处理）" class="headerlink" title="二值信号量和互斥锁有何异同（优先级反转的处理）"></a>二值信号量和互斥锁有何异同（优先级反转的处理）</h1><p><font color="red">絮絮叨叨</font>：之前一直以为互斥锁就是用二值信号量来实现的，但是发现两个还是有本质区别。</p><h2 id="信号量和互斥锁"><a href="#信号量和互斥锁" class="headerlink" title="信号量和互斥锁"></a>信号量和互斥锁</h2><p><strong>信号量</strong>：信号量本质是一种同步机制，用于线程间同步（时间先后顺序）。</p><p>信号量典型用例是一个生产者消费者模型，生产者线程进行V操作(释放信号量,信号量++)，消费者线程进行P操作(持有信号量，信号量–)，信号量为0时，消费无法持有信号量，进入挂起等待状态。</p><p><strong>互斥量</strong>：互斥量本质是一种锁机制，也叫互斥锁，用于处理资源共享（资源同时只能有一人访问）<br>互斥锁典型使用场景是设备的访问，在同一时刻只能由一个线程访问。在使用设备前进行加锁,使用完成后进行解锁，在使用过程中由于资源被锁定，其他线程无法进行访问，从而实现临界资源的保护。</p><p><strong>二值信号量</strong>：只有0和1的信号量。<br>由于二值信号量和互斥量的特点极为相似，都是只有0和1两种状态，所以二值信号量经常会干互斥锁的活。</p><h2 id="二值信号量和互斥锁的异同"><a href="#二值信号量和互斥锁的异同" class="headerlink" title="二值信号量和互斥锁的异同"></a>二值信号量和互斥锁的异同</h2><p><strong>相同点</strong>：都只有两种状态，0和1，都可以用来作为共享资源的保护方式。</p><p><strong>不同点</strong>：</p><ol><li>互斥量只能由同一个线程加锁和解锁，二值信号量可以在不同的线程加锁和解锁。</li><li>互斥量有优先级，在高任务优先级等待低优先级任务的资源时，会将低优先级的任务进行</li></ol><h2 id="什么是优先级反转"><a href="#什么是优先级反转" class="headerlink" title="什么是优先级反转"></a>什么是优先级反转</h2><p><strong>优先级反转</strong>：共享资源被低优先级的任务持有，高优先级任务等待解锁。这时中等优先级任务一直运行，这导致高优先级任务在等待低优先级任务，而低优先级任务无法执行。<br>这种高优先级等待中优先级的情况，叫做优先级反转。</p><p><strong>优先级继承</strong>：为了解决优先级反转而提出优化机制，让低优先级任务临时继承高优先级任务的优先级。在低优先级释放互斥锁之后，还要恢复原来的优先级。</p><p><strong>互斥量和二值信号量</strong></p><p>在上面提到，信号量和互斥量都可以实现资源的互斥访问，在优先级反转问题中，二者有重大区别。<br>互斥信号量是具有优先级继承的特点，而信号量没有该特点。使用互斥量可以处理优先级反转，而信号量不能。</p><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p><img src="https://imgkr2.cn-bj.ufileos.com/7ce17a62-5d0a-4c87-a969-613f83d54018.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=OOjVvNQnetzsOc8iyHJI%252BWOAJ%252BE%253D&Expires=1616254393"></p><blockquote><p>部门举办活动，你选择一个会议室活动场地（会议室不能同时被使用，资源被锁定）。布置到一半经理过来说你之前的项目有问题，快过来修改一下（任务被抢占）。<br>过了一会老板说要用这个会议室，可是现在会议室被你放着各种东西，现在用不了（高优先级等待资源）。<br>所以老板只能等你用完会议室才能用（异常情况）。</p></blockquote><blockquote><p>这种高优先级任务等待低优先级的任务，叫做优先级反转。实际上不应该发生这种情况，也不会让这种情况发生。</p></blockquote><blockquote><p>正常情况是：在老板发现这个会议室被占用，而必须要使用它的时候，会让你停下经理安排的任务，然后赶快把它收拾好（低优先级任务先于中优先级任务执行，优先级继承），然后你收拾完后再去做经理安排的任务。</p></blockquote><p>回到二值信号量和互斥量，在上面的例子中，互斥量已经标记好这个资源是你在访问，所以老板可以找到你，然后把你的优先级提升，去释放资源。<br>而信号量可以由多个线程持有和释放，所以不知道是谁持有该资源（找不到你在吗），所以老板只能干等你把其他事情做完，释放资源后才能继续使用资源。</p><p><a href="https://zhuanlan.zhihu.com/p/90990453">https://zhuanlan.zhihu.com/p/90990453</a><br><a href="https://blog.csdn.net/huangweiqing80/article/details/83038154">https://blog.csdn.net/huangweiqing80/article/details/83038154</a><br><a href="https://blog.csdn.net/cherisegege/article/details/80938475">https://blog.csdn.net/cherisegege/article/details/80938475</a><br><a href="https://blog.csdn.net/qq_14820081/article/details/89131589">https://blog.csdn.net/qq_14820081/article/details/89131589</a><br><a href="https://blog.csdn.net/qq_34793133/article/details/80087727">https://blog.csdn.net/qq_34793133/article/details/80087727</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么建议少用if语句，不是运行效率</title>
    <link href="/2022/09/04/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E6%AF%94%E8%BE%83%20if%20%E5%92%8Cswitch%20%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82/"/>
    <url>/2022/09/04/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E6%AF%94%E8%BE%83%20if%20%E5%92%8Cswitch%20%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h1 id="从汇编角度比较-if-和switch-性能差异"><a href="#从汇编角度比较-if-和switch-性能差异" class="headerlink" title="从汇编角度比较 if 和switch 性能差异"></a>从汇编角度比较 if 和switch 性能差异</h1><p><strong>絮絮叨叨</strong> : 这个五一就好好的当个技术宅吧，把之前欠的作业给补上，后面争取稳定周更一篇</p><h2 id="if-和-switch-性能差异"><a href="#if-和-switch-性能差异" class="headerlink" title="if 和 switch 性能差异"></a>if 和 switch 性能差异</h2><p>在写代码的时候肯定会用到不少if和switch语句，除了我们都知道的用法上的差异，性能上有什么差异。</p><p>这篇文章尝试从汇编的角度去解决下面的几个问题。</p><ul><li>影响if和switch性能的差异点在哪，他们有何异同。</li><li>if和switch的差异临界点在那，什么时候if和swtich的性能是一样的？</li><li>如何选择使用if和swtich。</li></ul><blockquote><p>以下分析运行环境为 centos7 ， gcc8.3</p></blockquote><h2 id="if-和-switch-用法区别"><a href="#if-和-switch-用法区别" class="headerlink" title="if 和 switch 用法区别"></a>if 和 switch 用法区别</h2><p>if 和 switch 用法的区别导致了他们在运行时效率差异的根本原因。</p><p>先看两段代码：<br>代码一（test_if.c）：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;constant.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">test_if</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;    <span class="hljs-type">int</span> result;    <span class="hljs-keyword">if</span> (num == VALUE1)    &#123;        result = num + <span class="hljs-number">5</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == VALUE2)    &#123;        result = num + <span class="hljs-number">9</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == VALUE3)    &#123;        result = num + <span class="hljs-number">12</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == VALUE4)    &#123;        result = num + <span class="hljs-number">15</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == VALUE5)    &#123;        result = num + <span class="hljs-number">31</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>代码二（test_switch.c）：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;constant.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">test_switch</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;    <span class="hljs-type">int</span> result = num;    <span class="hljs-keyword">switch</span> (num)    &#123;    <span class="hljs-keyword">case</span> VALUE1:        result = num + <span class="hljs-number">5</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> VALUE2:        result = num + <span class="hljs-number">9</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> VALUE3:        result = num + <span class="hljs-number">12</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> VALUE4:        result = num + <span class="hljs-number">15</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> VALUE5:        result = num + <span class="hljs-number">31</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        result = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>其中 <code>VALUE1</code>,<code>VALUE2</code>,<code>VALUE3</code>是在头文件<code>constant.h</code>定义的宏：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONSTANT_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONSTANT_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE1 101</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE2 103</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE3 105</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE4 107</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE5 111</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>上面的两段测试代码,完成相同功能：将传入的参数加上一个值后返回。</p><p>在if语句的测试代码中，使用if-else对所有条件进行逐一判断，满足条件后执行对应的代码。</p><p>而在swtich的测试代码中，直接根据num的值，跳转到对应标签的代码段执行。</p><p>if和switch都可以根据不同的输入，选择执行对应的代码，但是用用法上看，if语句需要对条件逐一判断，而switch语句，则不要判断直接可以跳转到对应的代码。</p><p>在我的理解中，switch语句有点像一个哈希表，实现<strong>整形数字到一个地址空间的映射</strong>，在使用时整形数字作为键（key），然后跳转到对应代码的地址（value）去执行。</p><p>然而在C语言中不存在map这种数据结构，在CPU的指令中也不存在这样的指令。</p><h2 id="if-和-switch-汇编代码分析"><a href="#if-和-switch-汇编代码分析" class="headerlink" title="if 和 switch 汇编代码分析"></a>if 和 switch 汇编代码分析</h2><p>在switch语句中，实现了类似哈希表（hash table）的数据结构。<br>在C语言中并不直接支持哈希表，如果要使用则必须自行设计相关代码。</p><p>通过汇编命令<code>gcc -S -O1 test_switch.c -o test_switch.s</code>查看gcc在编译时如何处理switch语句。</p><p>上面两段程序对应的汇编代码如下：<br>test_if.s</p><div class="code-wrapper"><pre><code class="hljs mel">test_if:.LFB0:.cfi_startprocmovl$106, %eax  ;设置返回值寄存器为<span class="hljs-number">106</span>cmpl$101, %edi  ;将参数和立即数<span class="hljs-number">101</span>比较，相等将ZF标志位置位je.L1        ;如果ZF置位，则跳转到L1movl$112, %eaxcmpl$103, %edije.L1movl$117, %eaxcmpl$105, %edije.L1movl$122, %eaxcmpl$107, %edije.L1cmpl$111, %edimovl$0, %eaxmovl$142, %edxcmove%edx, %eax.L1:              ;返回ret</code></pre></div><p>switch_test.s</p><div class="code-wrapper"><pre><code class="hljs jboss-cli">test_switch:<span class="hljs-string">.LFB0</span>:subl$101, %edi   ;计算根据参数，计算索引值cmpl$10, %edi    ;索引大于10，则跳转（与下面语句配合使用）ja<span class="hljs-string">.L9</span>            ;如果CF=0 且 ZF=0，跳转到default代码段,movl%edi, %edijmp*<span class="hljs-string">.L4</span><span class="hljs-params">(,%rdi,8)</span>  ;跳转到索引对应的地址标号<span class="hljs-string">.section</span><span class="hljs-string">.rodata</span><span class="hljs-string">.align</span> 8<span class="hljs-string">.align</span> 4<span class="hljs-string">.L4</span>:                 ;地址标号跳转表<span class="hljs-string">.quad</span><span class="hljs-string">.L8</span><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-string">.quad</span><span class="hljs-string">.L7</span><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-string">.quad</span><span class="hljs-string">.L6</span><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-string">.quad</span><span class="hljs-string">.L5</span><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-string">.quad</span><span class="hljs-string">.L3</span><span class="hljs-string">.text</span><span class="hljs-string">.L8</span>:movl$106, %eax  ; 将结果放入返回值寄存器ret               ; 返回<span class="hljs-string">.L7</span>:movl$112, %eaxret<span class="hljs-string">.L6</span>:movl$117, %eaxret<span class="hljs-string">.L5</span>:movl$122, %eaxret<span class="hljs-string">.L3</span>:movl$142, %eaxret<span class="hljs-string">.L9</span>:movl$0, %eaxret</code></pre></div><blockquote><p>注：为了简单汇编代码长度，在编译汇编代码，开启了1级优化，不同等级优化的汇编结果不同。</p></blockquote><p>在test_if对应的汇编代码中，可以很明显的看到程序处理逻辑为：依次判断是否满足条件，满足条件则执行对应代码。</p><p>在switch的汇编代码中，可以发现程序逻辑明显不同与if-else语句。</p><p>在switch的汇编中，首先将所有case对应的代码开始地址，放到L4标号所对应的连续地址中。<br>它可以理解为生成了一个常量数组<code>const uint32_t L4[VALUE5-VALUE1]=&#123;...&#125;;</code>，其数组内容顺序是按照处理case处理后的索引排序。<br>例如<code>VALUE3</code>对应的值为103，首先生成索引103-100&#x3D;3，然后<code>L4[3]</code>对应的值就是case 103 所在的代码开始地址。</p><p>在switch的汇编中，为了实现直接跳转功能，使用数组实现了一个哈希表，而对应的哈希函数由编译器自动生成，在上面代码中哈希函数为 <code>value = L4[key-100];</code><br>实际上这种应该叫跳转表（jump table），而不是哈希表（hash table）。</p><h2 id="if-和switch性能差异比较"><a href="#if-和switch性能差异比较" class="headerlink" title="if 和switch性能差异比较"></a>if 和switch性能差异比较</h2><p>通过汇编代码的比较可以发现，使用 test_switch.o 的代码大小比 test_if.o 的代码大小要高出不少，test_if.o大小为105字节，而test_swtch.o大小为189字节。</p><p><img src="https://files.mdnice.com/user/11205/2fa4ee83-f1d1-4831-9cde-76fe4f6ea53a.png"></p><p>这是鱼和熊掌不可兼得的一个体现，switch 语句减少了判断的时间，但是引进跳转表增加了代码空间，不过在大多数情况下这种代价是划算的。</p><p>不过通过对上面的汇编代码分析，需要质疑的是switch语句的效率一直if语句高吗？</p><p>在上面的汇编代码中知道，switch实际是使用跳转表实现的，如果各项case值差异很大呢，它还会生成跳转表吗？</p><p>我们把之前头文件对应VALUE的值改动后，重新生成汇编代码查看：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE1 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE2 10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE3 30</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE4 50</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE5 111</span></code></pre></div><p>汇编代码：</p><div class="code-wrapper"><pre><code class="hljs c">test_switch:.LFB0:.cfi_startproccmpl$<span class="hljs-number">30</span>, %edije.L4jle.L9movl$<span class="hljs-number">65</span>, %eaxcmpl$<span class="hljs-number">50</span>, %edije.L1cmpl$<span class="hljs-number">111</span>, %edimovl$<span class="hljs-number">0</span>, %eaxmovl$<span class="hljs-number">142</span>, %edxcmove%edx, %eaxret.L9:movl$<span class="hljs-number">6</span>, %eaxcmpl$<span class="hljs-number">1</span>, %edije.L1cmpl$<span class="hljs-number">10</span>, %edimovl$<span class="hljs-number">0</span>, %eaxmovl$<span class="hljs-number">19</span>, %edxcmove%edx, %eaxret.L4:movl$<span class="hljs-number">42</span>, %eax.L1:ret</code></pre></div><p>可以发现在cese各项值之间差异很大，switch语句将退化为if结构，和if语句效率无明显差异。</p><h2 id="if-和-switch-选择"><a href="#if-和-switch-选择" class="headerlink" title="if 和 switch 选择"></a>if 和 switch 选择</h2><ol><li>在分支数量小于4时，两者无明显差异，都是使用 cmp-jmp 指令进行处理。</li><li>在分支数量大于4，且case间跨度较小时，编译器使用跳转表可加快处理时间。</li><li>在case值跨度比较大时，switch语句退化为cmp-jmp 指令，性能无明显差异。</li><li>在分支数量比较多跨度比较大，且需要加快处理时间，可自行设计数据结构实现跳转表。</li></ol><p><a href="https://blog.csdn.net/qq_31108501/article/details/51842166" title="gcc 优化选项"></a><br><a href="swtich%E8%AF%AD%E5%8F%A5" title="《深入理解计算机系统》"></a><br><a href="swtich%E8%AF%AD%E5%8F%A5" title="《C Primer Plus》"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>依赖注入和工厂模式有什么关系</title>
    <link href="/2022/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖注入和工厂模式有什么关系？（C语言示例）"><a href="#依赖注入和工厂模式有什么关系？（C语言示例）" class="headerlink" title="依赖注入和工厂模式有什么关系？（C语言示例）"></a>依赖注入和工厂模式有什么关系？（C语言示例）</h1><p><strong>絮絮叨叨</strong>：今天师傅让我给他讲讲什么是工厂模式，工厂模式又要怎么用。</p><p>虽然说知道什么是工厂模式，但是在还没在实际的代码中用过。于是乎又深入的学习了下，发现工厂模式其实我们都见过，只是并没意识到而已。</p><hr><h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><blockquote><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<a href="%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B" title="[工厂模式](https://www.runoob.com/design-pattern/factory-pattern.html)"></a></p></blockquote><p>按照我的理解就是：“<strong>工厂模式将创建对象和使用对象两个过程分离，对于使用者无需关心对象的产生过程，直接指定需要的对象即可使用该对象的方法</strong>”</p><p>举一个我们生活中实际的例子。</p><blockquote><p>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p></blockquote><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>在某一项目需要用到 EEPROM、Flash 这两个设备，分别保存不同数据。在使用常规写法是下面的代码。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; eeprom.c</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">eeprom_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化 EEPROM\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">eeprom_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;启用 EEPROM\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">eeprom_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">uint16_t</span> len)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;向EEPROM 地址:%x 写入%d 字节数据:%s\n&quot;</span>, addr, len, (<span class="hljs-type">char</span> *)data);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; eeprom.h</span><span class="hljs-type">void</span> <span class="hljs-title function_">eeprom_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">eeprom_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">eeprom_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">uint16_t</span> len)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; flash.c</span><span class="hljs-type">void</span> <span class="hljs-title function_">flash_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化 FLASH\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">flash_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;启用 FLASH\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">flash_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">uint16_t</span> len)</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;向FLASH 地址:%x 写入%d 字节数据:%s\n&quot;</span>, addr, len, (<span class="hljs-type">char</span> *)data);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; flash.h</span><span class="hljs-type">void</span> <span class="hljs-title function_">flash_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">flash_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">flash_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">uint16_t</span> len)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; main.c</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;eeprom.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flash.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">char</span> *str[] = &#123;<span class="hljs-string">&quot;我是EEPROM&quot;</span>, <span class="hljs-string">&quot;我是FLASH&quot;</span>&#125;;    eeprom_init();    eeprom_open();    flash_init();    flash_open();    eeprom_write(<span class="hljs-number">0x0100</span>, str[<span class="hljs-number">0</span>], <span class="hljs-built_in">strlen</span>(str[<span class="hljs-number">0</span>]));    flash_write(<span class="hljs-number">0x02000100</span>, str[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>(str[<span class="hljs-number">1</span>]));&#125;</code></pre></div><p>运行结果为：</p><div class="code-wrapper"><pre><code class="hljs c">初始化 EEPROM启用 EEPROM初始化 FLASH启用 FLASH向EEPROM 地址:<span class="hljs-number">100</span> 写入<span class="hljs-number">12</span> 字节数据:我是EEPROM向FLASH 地址:<span class="hljs-number">2000100</span> 写入<span class="hljs-number">11</span> 字节数据:我是FLASH</code></pre></div><p>在上面的应用代码中（main函数）直接使用了eeprom和flash相关的API(包含eeprom.h和flash.h)，所以main 对eeprom、flash 产生了依赖。</p><p>如果后面嫌弃flash容量不够，而换成SD卡，那main 函数和flash相关的的API都需要更改，在频繁更换的场景这是繁琐的。</p><h2 id="使用工厂模式"><a href="#使用工厂模式" class="headerlink" title="使用工厂模式"></a>使用工厂模式</h2><p>使用工厂模式实现上述功能，代码需要怎么写呢？</p><p>工厂模式是使用一个工厂接口将其他类的所有创建初始化处理完成，对于应用程序无需关心创建的细节。</p><p>首先创建抽象出一个存储类，保存所有存储类信息到数组，然后创建工厂函数，在工厂函数中查找对应的实例，然后对它进行初始化。</p><p>我们保持上面的eeprom.c、flash.c 不变，创建一个factory.c和对应头文件。代码如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; factory.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">storage</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">char</span> *name;    <span class="hljs-type">void</span> (*init)(<span class="hljs-type">void</span>);    <span class="hljs-type">void</span> (*open)(<span class="hljs-type">void</span>);    <span class="hljs-type">void</span> (*write)( <span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint8_t</span> *, <span class="hljs-type">uint16_t</span>);&#125; * <span class="hljs-type">storage_t</span>;<span class="hljs-type">storage_t</span> <span class="hljs-title function_">storage_factory</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt; factory.c</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">storage</span> <span class="hljs-title">storage_list</span>[] =</span>&#123;    &#123;<span class="hljs-string">&quot;eeprom&quot;</span>, eeprom_init, eeprom_open, eeprom_write&#125;,    &#123;<span class="hljs-string">&quot;flash&quot;</span>, flash_init, flash_open, flash_write&#125;,&#125;;<span class="hljs-type">storage_t</span> <span class="hljs-title function_">storage_factory</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span>&#123;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(storage_list) / <span class="hljs-keyword">sizeof</span>(storage_list[<span class="hljs-number">0</span>]); i++)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">strcmp</span>(name, storage_list[i].name))        &#123;            storage_list[i].init();            storage_list[i].open();            <span class="hljs-keyword">return</span> &amp;storage_list[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">///&gt;&gt;main.c</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;factory.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">char</span> *str[] = &#123;<span class="hljs-string">&quot;我是EEPROM&quot;</span>, <span class="hljs-string">&quot;我是FLASH&quot;</span>&#125;;    <span class="hljs-type">storage_t</span> byte_data = storage_factory(<span class="hljs-string">&quot;eeprom&quot;</span>);    <span class="hljs-type">storage_t</span> sector_data = storage_factory(<span class="hljs-string">&quot;flash&quot;</span>);    byte_data-&gt;write(<span class="hljs-number">0x0100</span>, str[<span class="hljs-number">0</span>], <span class="hljs-built_in">strlen</span>(str[<span class="hljs-number">0</span>]));    sector_data-&gt;write(<span class="hljs-number">0x02000100</span>, str[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>(str[<span class="hljs-number">1</span>]));&#125;</code></pre></div><p>在这一份代码中，main 、eeprom 和 flash 之间的耦合解除了，main.c 的依赖变成了factory 。运行结构依旧和上面相同。</p><p>而如果需要将flash 换成 sd 卡，则main 函数只需将 工厂创建时传递的名字改成sd，并在factory添加对应的处理操作方法即可。</p><h2 id="身边的工厂模式"><a href="#身边的工厂模式" class="headerlink" title="身边的工厂模式"></a>身边的工厂模式</h2><p>不知道有人对上面的第二中代码是否感到熟悉，在C语言的文件操作，linux 的设备驱动，都是使用类似的方式初始化并开启设备。</p><p>而对于使用者而言，我们并不需要对设备的初始化流程有了解，只需要使用 fopen\open 函数进行打开需要的文件名，其他过程在内部已经将这些完成。</p><p>所有从某种角度而言，open\fopen 函数就是一个工厂的入口，它将具体的设备初始化细节进行屏蔽。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在上面的第一种方法，其实属于面向过程编程。</p><p>在第二种方法，使用结构体将eeprom和flash抽象成了一个存储类，变成了简单的面向对象编程。</p><p>在上面的过程中，依赖关系从<code>main 依赖 eeprom</code>  变成了 <code> main 依赖 factory</code> ，从而达到解耦的目的。<br>或者还可以说，eeprom 通过 factory 向 main 中注入了依赖关系，这也就是<strong>依赖注入</strong>。</p><p><a href="https://www.zhihu.com/question/279991129/answer/419915018" title="[设计模式中的工厂模式和依赖注入之间有什么关系](https://www.zhihu.com/question/279991129/answer/419915018)"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>变长数组和柔性数组</title>
    <link href="/2022/09/04/%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E5%92%8C%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
    <url>/2022/09/04/%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E5%92%8C%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="变长数组和柔性数组"><a href="#变长数组和柔性数组" class="headerlink" title="变长数组和柔性数组"></a>变长数组和柔性数组</h1><p><strong>絮絮叨叨：</strong> 让人不开心的事，不去做就好</p><h2 id="数组的变种"><a href="#数组的变种" class="headerlink" title="数组的变种"></a>数组的变种</h2><p>我们常规使用的数组大部分都是C89标准的功能，在C99标准中添加了对变长数组和零长度数组的支持。</p><p>这两种新的特性有时会给开发带来不错的效果。</p><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>变长数组（variable-length array）并不是长度可以变化的数组。</p><p>在最开始学习C语言时，基本都强调过数组的长度是不可变的，同样这句话依然适用。</p><p>这里指的变长，是在定义数组的时候长度可变，而不是在使用数组时长度可变。<br>即<strong>定义数组时的数组长度可以是变量</strong>。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cpy</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;  <span class="hljs-type">char</span> src[]=<span class="hljs-string">&quot;hello wolrd&quot;</span>;  <span class="hljs-type">char</span> *offset = <span class="hljs-built_in">strchr</span>(src,<span class="hljs-string">&#x27; &#x27;</span>);  <span class="hljs-type">int</span> len = offset - src;  <span class="hljs-type">char</span> dest[len];  <span class="hljs-built_in">strncpy</span>(dest, src, len);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,dest);&#125;</code></pre></div><p>不过在使用中还是有些限制条件：</p><ul><li>数组类型必须时自动存储类型; （不能定义或者声明为extern 和static）</li><li>变成数组不能进行初始化</li></ul><h2 id="零长度数组"><a href="#零长度数组" class="headerlink" title="零长度数组"></a>零长度数组</h2><p>你没看错，就是零长度为0的数组，或者也可以叫做柔性数组。<br>先看零长数组的用法:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pack</span>&#123;</span><span class="hljs-type">uint32_t</span> length;  <span class="hljs-type">uint32_t</span> crc32;<span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];    <span class="hljs-comment">//与 char data[]; 等价</span>&#125;;</code></pre></div><p>在一个结构体的最后一个元素中声明一个数组，数组的大小不定义或者定义0，最后这个数组则为零长度数组。</p><p>需要明确的零长度数组只是一个声明或者标识符，而不存在一个实体（内存）与之对应。</p><p>它在结构体中, 只是代表了一个偏移量, 代表一个不可修改的地址常量，其本身并不占空间。</p><div class="code-wrapper"><pre><div class="caption"><span>pack)```的值为8字节。</span></div><code class="hljs sizeof(struct">这个也是在许多面试中，和字节对齐一起，常考的一个知识点。这种方式的声明和下面的声明有本质区别```c//64位平台struct pack2&#123;uint32_t length;  uint32_t crc32;char *data;&#125;;</code></pre></div><div class="code-wrapper"><pre><div class="caption"><span>pack2)```的值为16字节。</span></div><code class="hljs sizeof(struct">在struct pack2中，data是一个指针其有一个自己的内存空间。下面是使用零长度数组构造的一个简单通信协议示例```cint pack_data(char *data)&#123;  struct pack *p;  uint32_t pack_size;  p-&gt;len = strlen(data);  p-&gt;crc32 = crc32(data,p-&gt;len);  pack_size =sizeof(struct pack) + p-&gt;len;  malloc(pack_size);  memcpy(p-&gt;data, data, p-&gt;len);  send_pack(p, pack_size);  free(p);  return pack_size;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>喜大奔普，wsl原生支持GUI了</title>
    <link href="/2022/09/04/%E5%96%9C%E5%A4%A7%E5%A5%94%E6%99%AE%EF%BC%8Cwsl%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81GUI%E4%BA%86/"/>
    <url>/2022/09/04/%E5%96%9C%E5%A4%A7%E5%A5%94%E6%99%AE%EF%BC%8Cwsl%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81GUI%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p>前两天偶然发现，WSL2 竟然原生支持 GUI 了，这个可能是 Win11 给我带来的唯一惊喜吧~</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>用一个来形容使用体验就是爽! 现在可以完全抛弃双系统，什么 X11 的也统统消失吧~</p><p>首先看下基本使用方式：</p><ol><li>在 WSL2 的命令行输入命令后，会直接出现一个窗口显示对应的 GUI</li></ol><p><img src="https://files.mdnice.com/user/11205/fba8ade6-8919-4d1a-a3ad-3f716533603b.png" alt=" nautilus ~"></p><ol start="2"><li>在 Windows11 的开始菜单中点击图标启动（可以直接在搜索栏中搜索程序）</li></ol><p><img src="https://files.mdnice.com/user/11205/32c87e19-14e4-4f71-a8b9-207fae997a8d.png"></p><p>当你在 WSL2 中安装新的应用程序后，会像 Ubuntu 一样在菜单中生成图标</p><p><img src="https://files.mdnice.com/user/11205/332d06e7-3eec-4434-b54c-a9394e41211a.png"></p><ul><li>在使用时，windows 应用和 Linux 应用之间可以使用 Alt-Tab 键无缝切换</li><li>跨 Windows 和 Linux 应用剪切 + 粘贴</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ul><li>系统要求：需要使用 Windows 11 内部版本 22000 或更高版本（刚好满足~）</li></ul><p><img src="https://files.mdnice.com/user/11205/7e693e6f-797d-4a62-b666-b718e977b058.png"></p><h3 id="检查-WSL-版本"><a href="#检查-WSL-版本" class="headerlink" title="检查 WSL 版本"></a>检查 WSL 版本</h3><p>只有 WSL2 才支持原生 GUI，输入 <code>wsl -l -v</code>  命令，查看当前 WSL 版本<br><img src="https://files.mdnice.com/user/11205/0c39961c-1bb8-44cd-a5ee-64ea2d35ef81.png" alt="VERSION 显示 2 才可以 "></p><h3 id="升级-WSL2-（已安装的忽略）"><a href="#升级-WSL2-（已安装的忽略）" class="headerlink" title="升级 WSL2 （已安装的忽略）"></a>升级 WSL2 （已安装的忽略）</h3><ol><li><p>由于 WSL2 使用虚拟机方式，提供了完整的 Linux 内核的功能，所以需要开启虚拟化功能(PowerShell 中管理员身份运行)：</p><div class="code-wrapper"><pre><code class="hljs PowerShell">dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</code></pre></div></li><li><p>安装 WSL2 内核包<br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p></li><li><p>将 WSL 2 设置为默认版本<br>打开 PowerShell 并运行以下命令，以在安装新的 Linux 发行版时将 WSL 2 设置为默认版本(PowerShell 中管理员身份运行)：</p><div class="code-wrapper"><pre><code class="hljs PowerShell">wsl <span class="hljs-literal">--set-default-version</span> <span class="hljs-number">2</span></code></pre></div></li></ol><h3 id="WSL2-升级"><a href="#WSL2-升级" class="headerlink" title="WSL2 升级"></a>WSL2 升级</h3><ol><li>输入 WSL 更新命令(PowerShell 中管理员身份运行)：</li></ol><div class="code-wrapper"><pre><code class="hljs PowerShell">wsl <span class="hljs-literal">--update</span></code></pre></div><ol start="2"><li>重新启动 WSL (PowerShell 中管理员身份运行)：</li></ol><div class="code-wrapper"><pre><code class="hljs PowerShell">wsl <span class="hljs-literal">--shutdown</span></code></pre></div><p>执行完上面步骤后，就可以正常像 Ubuntu 中一样使用带 GUI 的程序了。</p><p>我在 WSL2 中安装了一套完整的桌面系统进行测试，在启动 GNOME 后，会显示一套 Ubuntu 的桌面 GUI, 状态栏和图标等一应俱全。甚至还可以使用 Crtl-Alt+T 快捷键去启动终端。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>太占系统资源，由于 WSL 默认是安装在 C 盘，我一套软件安装下来后，发现 C 盘直接红了（本来也快了）</li></ol><p><img src="https://files.mdnice.com/user/11205/406b1ce8-6d1f-4972-8510-ab7224b241e3.png"></p><p>同时在任务管理器中可以看到 WSL2 所占用的内存，在正常使用时内存占用远比直接运行 Ubuntu 的内存占用高不少。<br><img src="https://files.mdnice.com/user/11205/6d0d86b4-9179-4bd1-a748-1c41c62063a4.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WSL2 的这个功能让我感觉非常好，可以省去 X11 麻烦的配置，而且 GUI 的使用体验更好。</p><p>但是一个完整的桌面系统就没必要了，毕竟使用 WSL 的目的，并不是看上了 Linux 的桌面才使用的。</p><p>使用 VSCode 的终端加文本编辑功能，配合原生支持的 GUI 窗口已经足够满足大部分需求了。</p><p>而那些资源占用虽然有点多，但这是 WSL2 无法避免的（好像微软出品的软件内存就没低过。。。。）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安全函数不安全--多线程慎用list.h</title>
    <link href="/2022/09/04/%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AE%89%E5%85%A8--%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%85%8E%E7%94%A8list.h/"/>
    <url>/2022/09/04/%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AE%89%E5%85%A8--%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%85%8E%E7%94%A8list.h/</url>
    
    <content type="html"><![CDATA[<h1 id="安全函数不安全–多线程慎用list-h"><a href="#安全函数不安全–多线程慎用list-h" class="headerlink" title="安全函数不安全–多线程慎用list.h"></a>安全函数不安全–多线程慎用list.h</h1><p>絮絮叨叨： 一个 BUG 轻轻松松让我少了几个小时的睡眠时间！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux 开发应该多少都听过大名鼎鼎的 list.h ，其简洁优雅的设计，一个头文件完成了一个高可用的链表。</p><p>但是 list.h 并不是线程安全的，在多线程的情况下使用，必须考虑多线程数据同步的问题。</p><p>然而。。。。</p><p>我在使用互斥锁对链表的操作进行保护之后，还是被坑了！</p><p>下面是把我坑了的 list_for_each_entry 和 list_for_each_entry_safe 两个函数的详细分析。</p><h2 id="list-h-单线程使用"><a href="#list-h-单线程使用" class="headerlink" title="list.h 单线程使用"></a>list.h 单线程使用</h2><p>在 list.h 这个文件中有非常多值得学习的地方，比如其最经典的 container_of 的实现。</p><p>在这里只介绍几个常用的函数，然后重点分析在多线程使用时的碰到的坑。</p><h3 id="链表初始化及添加节点"><a href="#链表初始化及添加节点" class="headerlink" title="链表初始化及添加节点"></a>链表初始化及添加节点</h3><p>首先定义一个链表和链表节点，定义一个产品，其属性为产品重量(weight)。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">product_s</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">product_node</span>;</span>    <span class="hljs-type">uint32_t</span> index;    <span class="hljs-type">uint32_t</span> weight;&#125;<span class="hljs-type">product_t</span>;<span class="hljs-comment">//初始化链表头</span>LIST_HEAD(product_list);</code></pre></div><p>生产者在生产完产品后，将产品加入链表，等待消费者使用。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">product_t</span> *product = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">product_t</span>));    <span class="hljs-comment">// 产品重量为 300 ± 10</span>    product-&gt;weight = <span class="hljs-number">290</span> + rand() % <span class="hljs-number">20</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;product :%p, weight %d\n&quot;</span>, product, product-&gt;weight);    list_add_tail(&amp;product-&gt;product_node, &amp;product_list);&#125;</code></pre></div><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><p>使用 <code>list_for_each_entry</code> 可以将链表进行遍历：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 遍历打印链表信息</span><span class="hljs-type">void</span> <span class="hljs-title function_">print_produce_list</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">product_t</span> *product;    list_for_each_entry(product, &amp;product_list, product_node)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;manufacture product :%p, weight %d\n&quot;</span>, product, product-&gt;weight);    &#125;&#125;</code></pre></div><p>其具体实现是使用宏将 for 循环的初始条件和完成条件进行了替换：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry(pos, head, member)                \</span><span class="hljs-meta">    for (pos = list_first_entry(head, typeof(*pos), member);    \</span><span class="hljs-meta">         &amp;pos-&gt;member != (head);                    \</span><span class="hljs-meta">         pos = list_next_entry(pos, member))</span></code></pre></div><p>其中for循环的第一个参数将 <code>pos = list_first_entry(head, typeof(*pos), member);</code> 初始化为链表头指向的第一个实体链表成员。</p><p>第二个参数 <code>&amp;pos-&gt;member != (head)</code> 为跳出条件，当pos-&gt;member再次指向链表头时跳出for循环。</p><p>for的第三个参数通过pos-&gt;member.next指针遍历整个实体链表，当pos-&gt;member.next再次指向我们的链表头的时候跳出for循环。</p><p>但是 <font color=red size=4 face="黑体"> list_for_each_entry 不能在遍历的循环体中删除节点</font>，因为在循环体中删除链表节点后，当前节点的前驱结点和后继结点指针会被置空。</p><p>在for循环的第三个参数中，获取下一个节点时，会发生非法指针访问</p><p><img src="https://files.mdnice.com/user/11205/0b0e55fd-86b1-4cd9-89ac-c710678e9f90.png"></p><h3 id="“安全遍历链表”"><a href="#“安全遍历链表”" class="headerlink" title="“安全遍历链表”"></a>“安全遍历链表”</h3><p>为了解决在遍历链表过程中，无法删除结点的问题，在 list.h 中提供了一个安全删除节点的函数</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 删除重量小于300的节点</span><span class="hljs-type">void</span> <span class="hljs-title function_">remove_unqualified_produce</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">product_t</span> *product, *temp;    list_for_each_entry_safe(product, temp, &amp;product_list, product_node)    &#123;        <span class="hljs-comment">// 移除重量小于300的产品</span>        <span class="hljs-keyword">if</span> (product-&gt;weight &lt; <span class="hljs-number">300</span>)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;remove product :%p, weight %d\n&quot;</span>, product, product-&gt;weight);            list_del(&amp;product-&gt;product_node);            <span class="hljs-built_in">free</span>(product);        &#125;    &#125;&#125;</code></pre></div><p>其实现是使用一个中间变量，在开始每次开始执行循环体前，将当前节点的下一个节点保存到中间变量，从而实现”安全”遍历</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)            \</span><span class="hljs-meta">    for (pos = list_first_entry(head, typeof(*pos), member),    \</span><span class="hljs-meta">        n = list_next_entry(pos, member);            \</span><span class="hljs-meta">         &amp;pos-&gt;member != (head);                    \</span><span class="hljs-meta">         pos = n, n = list_next_entry(n, member))</span></code></pre></div><h2 id="多线程中使用list-h"><a href="#多线程中使用list-h" class="headerlink" title="多线程中使用list.h"></a>多线程中使用list.h</h2><p>上面我们在主线程里面创建了产品，并放入到链表中并，并过滤了重量小于300的产品。</p><p>后面我们在多线程中对产品进行消费（两个线程同时消费链表的数据，使用完成后删除并释放结点）。</p><p>这里的逻辑和单线程中的差不多，同样是遍历链表，然后从链表中删除节点。不同的是，由于list.h自身没有带锁，所以需要使用互斥锁将链表的操作进行保护。</p><p>于是很自然的有了下面的代码</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;    <span class="hljs-type">product_t</span> *product, *temp;    <span class="hljs-comment">// 使用互斥锁对链表进行保护</span>    pthread_mutex_lock(&amp;producer_mutex);    list_for_each_entry_safe(product, temp, &amp;product_list, product_node)    &#123;        list_del(&amp;product-&gt;product_node);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;consume product :%p, weight %d, consumer :%p\n&quot;</span>, product, product-&gt;weight, (<span class="hljs-type">void</span> *)pthread_self());        pthread_mutex_unlock(&amp;producer_mutex);        <span class="hljs-comment">// 睡一会，防止太快了</span>        usleep(<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);        <span class="hljs-built_in">free</span>(product);        pthread_mutex_lock(&amp;producer_mutex);    &#125;    pthread_mutex_unlock(&amp;producer_mutex);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><p>在上面的这段代码中，在对链表操作时，使用互斥锁对链表进行了保护，使同时只能有一个线程访问链表。</p><p>不过你以为这样就好了嘛，如果时这样，这篇文章就没存在的必要了。。。</p><p><img src="https://files.mdnice.com/user/11205/73c76b7c-7b78-4bd3-81ad-f6ebf9199fad.png"></p><p>在两个线程同时遍历时，即便是加了锁之后，数据访问也不安全。</p><p>在遍历使用的 list_for_each_entry_safe 宏中，使用了一个零时变量对保存着当前链表的下一个节点。</p><p>但是多线程访问链表时，有可能零时变量保存的节点，被另一个线程删除了，所以访问的时候又是  <font color=red size=4 face="黑体">Segmentation fault <font></p><p><img src="https://files.mdnice.com/user/11205/c1104785-c69b-4332-b670-770d97190523.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>原因找到了，也就好办了。以至于解决方法嘛，我是使用一个全局的零时变量，将需要删除节点的下一个节点保存起来，手动实现多线程的”安全删除”。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 消费者</span><span class="hljs-type">void</span> * <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;    <span class="hljs-type">product_t</span> *product;    <span class="hljs-comment">// 使用互斥锁对链表进行保护</span>    pthread_mutex_lock(&amp;producer_mutex);    list_for_each_entry(product, &amp;product_list, product_node)    &#123;        temp = list_next_entry(product, product_node);        list_del(&amp;product-&gt;product_node);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;consume product :%p, weight %d, consumer :%p\n&quot;</span>, product, product-&gt;weight, (<span class="hljs-type">void</span> *)pthread_self());        pthread_mutex_unlock(&amp;producer_mutex);        <span class="hljs-comment">// 睡一会，防止太快</span>        usleep(<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);        <span class="hljs-built_in">free</span>(product);        pthread_mutex_lock(&amp;producer_mutex);        <span class="hljs-keyword">if</span>(temp != <span class="hljs-literal">NULL</span>)&#123;            product = list_prev_entry(temp, product_node);        &#125;    &#125;    pthread_mutex_unlock(&amp;producer_mutex);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><p>一个晚上找到了这个bug，然后又花了一个晚上记录下来这个bug。</p><p>据说 klist.h 是 list.h 的线程安全版本，后面花时间在研究一下去，今天就先睡了。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米温湿度计拆解</title>
    <link href="/2022/09/04/%E5%B0%8F%E7%B1%B3%E6%B8%A9%E6%B9%BF%E5%BA%A6%E8%AE%A1%E6%8B%86%E8%A7%A3/"/>
    <url>/2022/09/04/%E5%B0%8F%E7%B1%B3%E6%B8%A9%E6%B9%BF%E5%BA%A6%E8%AE%A1%E6%8B%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>絮絮叨叨：心情不好，码字转移注意力…</p><h2 id="小米温湿度计拆解"><a href="#小米温湿度计拆解" class="headerlink" title="小米温湿度计拆解"></a>小米温湿度计拆解</h2><p>前段时间去朋友家，看到它桌子上的时钟，被吸引了注意力，极其简洁的外观和清晰的显示。</p><p><img src="https://files.mdnice.com/user/11205/6103375c-9d14-4598-90bb-192ad8f6e545.png"></p><p>这就是<strong>米家电子温湿度计 Pro</strong> 。</p><p>看到这个符号的显示我惊了，电子墨水屏有这么好的清晰度吗，于是乎也买了一个。想着用来改装做一个自己的显示屏。</p><p><img src="https://files.mdnice.com/user/11205/7b245a97-dec4-417d-bd2b-059f17af5b59.png"></p><p>拆开外壳，一个非常简单的 PCB 板，正面一共 20 个阻容元件、4 个二极管、3 个晶振、4颗芯片以及三粒电池，背面无元件。</p><p><img src="https://files.mdnice.com/user/11205/1213a60e-c1cd-40c8-bb44-c0ce24091acf.png"></p><p>放大仔细观察发现，主控芯片 U5 为：<strong>DA14585</strong>、 U2 为温湿度传感器（网上查找发现为SHTC3）、U3 为 RTC 时钟芯片（HYM8563, 网上拆机为 BM8563），U4 芯片功能未知，丝印 5W2 93 JDG。</p><p><img src="https://files.mdnice.com/user/11205/9133eda6-4d9e-4260-9d5b-b6e6d972c058.png"></p><h2 id="原理图抄板"><a href="#原理图抄板" class="headerlink" title="原理图抄板"></a>原理图抄板</h2><p>知道芯片型号后，抄板就简单多了。<br>从官网或者立创扒拉到芯片数据手册，对照封装和参考原理图，用万用表把 PCB 上的焊点一个一个测试一遍。</p><h3 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h3><p>原理图分析首先从电源开始，PCB 一共有三节电池，两节 CR2302, 一节 CR1202。</p><p><img src="https://files.mdnice.com/user/11205/e2bba93c-ab3b-43bb-8a87-9fc1eeae2a43.png"></p><p>其中两节 CR2302 （B1,B2）电池并联作为主电源为主控芯片供电，由两个肖特基二极管（D8,D8 丝印 S12）来防止电流反灌。</p><p>CR1202 电池作为 RTC 备用电池，通过两个开关二极管（D5，D6）进行电池切换。</p><p>在正面有两个测试点，左边为电源负极（GND 网络，B2 丝印下方），右边为电源负极（3V0 网络，B1 丝印下方）。</p><h3 id="主控电路"><a href="#主控电路" class="headerlink" title="主控电路"></a>主控电路</h3><p>主控电路完全参考 DA14585 的参考电路进行绘制，需要注意的是芯片的封装是 QFN40, 画封装时还给整错了一次。。。</p><p><img src="https://files.mdnice.com/user/11205/142dc23c-e9a0-47c9-b5ae-b2b3233fe3f2.png" alt="DA14585的参考原理图"></p><h3 id="接口电路"><a href="#接口电路" class="headerlink" title="接口电路"></a>接口电路</h3><p>该 PCB 一共使用了三个接口，两个 IIC 分别接到 RTC 芯片和温湿度计，一个 SPI 接口作为屏幕控制。</p><p><img src="https://files.mdnice.com/user/11205/ae13d9d6-1e4e-403c-bd46-96e19c800c0e.png"></p><p>DA14585 的外设输出可以映射到任意引脚，所以只需要知道引脚编号，即可配置输出了</p><p>最后也是最重要的下载接口，它是通过测试点引出，部分测试点的功能如下。<br><img src="https://files.mdnice.com/user/11205/5b4813b9-6b3d-4d58-b047-00d924921f11.png"></p><h2 id="屏幕通信协议抓包"><a href="#屏幕通信协议抓包" class="headerlink" title="屏幕通信协议抓包"></a>屏幕通信协议抓包</h2><p>由于屏幕和外壳粘在一起，屏幕型号未知，同时和朋友讨论后，从成本和效果分析，屏幕应该不是普通的电子墨水屏，而很可能是定制的段码电子墨水屏。</p><p>对于定制屏幕，无法拿到手册，只能使用逻辑分析仪手动抓包分析时序。</p><p>不过这协议分析暂时未完成，所以等到后面在写（如果不会鸽的话~）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>运行在MCU上的Linux-Nuttx 简介</title>
    <link href="/2022/09/04/%E8%BF%90%E8%A1%8C%E5%9C%A8MCU%E4%B8%8A%E7%9A%84Linux-Nuttx%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/04/%E8%BF%90%E8%A1%8C%E5%9C%A8MCU%E4%B8%8A%E7%9A%84Linux-Nuttx%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>之前在论坛看到过一篇帖子，说怎么在 STM32 上移植 Linux ，帖子写了很长，最后才发现使用的 uclinux，而且还是只启动一个 uboot。</p><p>现在想想为什么需要在 STM32 这种 MCU 上移植 Linux 呢，个人猜测可能是因为 Linux 环境丰富的组件和软件可移植性吧。</p><p>可是如果有一个 mini 版的 Linux 系统可以用呢，而且还不需要移植上手即用，这个就是  Nuttx。</p><h2 id="NUTTX-简介"><a href="#NUTTX-简介" class="headerlink" title="NUTTX 简介"></a>NUTTX 简介</h2><p>NuttX 可拓展的实时操作系统，在2017年由 Gregory Nutt 发布， 并在2019年在正式进入Apache基金会，成为 Apache 孵化项目。</p><p>它最大的特点是：</p><ul><li><p><strong>高度可扩展性</strong>：Nuttx 支持8位到64位多种 CPU，其功能全部可进行裁剪和配置，可根据需要选择所需的组件。</p></li><li><p><strong>合规性</strong>：Nuttx 的系统 API 原生支持标准 POSIX 接口和完整的 C 标准库，这让一些 Linux&#x2F;Unix 的程序可以很方便的移植到 Nuttx 中使用，而不需要做太多更改。</p></li></ul><p>（吐槽一下：在之前使用其他 RTOS 的 Posix 接口使用体验并不太友好：FreeRTOS 支持的 POSIX 接口仅包含线程的的部分，缺少文件按系统支持使用总感觉有点鸡肋。RT-Thread 在组件中支持了 POSIX 线程的部分也有文件系统，但是使用的时候总会有一两处不同让人心烦意乱）</p><p>除此之外 Nuttx 还有丰富的系统组件：</p><ul><li><p><strong>文件系统</strong>：Nuttx 支持多种不同的文件系统，包括但不限于 LittleFS、 ROMFS、NFS、FATFS 等等，甚至你还可以在 Nuttx 中挂载一个 FTP 服务器~</p></li><li><p><strong>设备驱动</strong>： Nuttx 提供了丰富统一的设备和总线驱动，在不同芯片平台可使用相同的方式访问设备。包括网络、USB、SDIO、TFT 等多种总线或者设备。</p></li><li><p><strong>网络支持</strong>：Nuttx 中支持了 IPv4、IPv6、TCP&#x2F;IP、ICMP、BT、BLE 等多种协议栈，还支持 DHCP、SMTP、Telnet 、FTP、HTTP 等多种服务端和客户端，在使用中可无缝对接 Linux 程序。</p></li><li><p><strong>多核支持</strong>：在一些复杂应用的所使用 SOC，往往不止一个 CPU，Nuttx 中基于 OpenAMP 提供了一个强大的多核框架，能够在使用时完全忽略多核差异。</p></li></ul><h2 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h2><p>根据官方的文档，现在 Nuttx 已经支持了 16 中不同芯片架构，累计 280+ 中芯片。包括 TI、NXP、ST、乐鑫在内的众多常用芯片都已支持在内。</p><p>更重要的是 Nuttx 支持，在电脑中使用模拟器运行 nuttx。在开发时先在 sim 中调试验证完成后，在使用硬件进行调试，能够提高开发效率和缩短开发时间。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>开发 Nuttx 推荐使用 Ubuntu 20.04 进行开发，在 windows 中可以使用 wsl2 安装 Ubuntu 20.04 可获得相同体验。以下以 WSL2 （Ubuntu 20.04）为例进行说明。</p><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p><strong>安装编译工具</strong><br>由于 nuttx 在编译是会使用到一些额外的工具，所以需要提前安装一下依赖的工具。（其实下面的有些也不常用。。）</p><div class="code-wrapper"><pre><code class="hljs sh">sudo apt install \bison flex gettext texinfo libncurses5-dev libncursesw5-dev \gperf automake libtool pkg-config build-essential gperf genromfs \libgmp-dev libmpc-dev libmpfr-dev libisl-dev binutils-dev libelf-dev \libexpat-dev gcc-multilib g++-multilib picocom u-boot-tools util-linuxsudo apt install kconfig-frontendssudo apt install gcc-arm-none-eabi binutils-arm-none-eabi</code></pre></div><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> nuttx-learning<span class="hljs-built_in">cd</span> nuttx-learninggit <span class="hljs-built_in">clone</span> --depth=1 -b nuttx-10.2.0 https://github.com/apache/incubator-nuttx.git nuttxgit <span class="hljs-built_in">clone</span> --depth=1 -b nuttx-10.2.0 https://github.com/apache/incubator-nuttx-apps apps</code></pre></div><h3 id="配置编译"><a href="#配置编译" class="headerlink" title="配置编译"></a>配置编译</h3><p>在 Nuttx 的代码中默认包含所有支持的芯片驱动，所有无需下载额外的代码，只要根据需要选择你需要使用配置即可:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 进入 nuttx 目录</span><span class="hljs-built_in">cd</span> nuttx<span class="hljs-comment"># c查看所有可用的配置</span>./tools/configure.sh -L</code></pre></div><p>输入命令后会打印非常多配置，以 <code>sim:minibaisc</code> 为例，其中冒号前面的 sim 表示使用芯片，冒号后面的 minibasic 表示具体配置名称。</p><p>sim:minibasic 表示在模拟器中运行的最小程序配置，它编译完后它只包含一个 shell 和一个 hello world。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment"># 生成指定配置的配置信息</span>.<span class="hljs-regexp">/tools/</span>configure.sh -l sim:minibasic<span class="hljs-comment"># 编译程序</span>make -j</code></pre></div><p>编译完成后，在 nuttx 目录下(执行 make 的当前目录)，会生成一个 .&#x2F;nuttx 文件。</p><p><img src="https://files.mdnice.com/user/11205/c0b1b5f8-5239-4408-b4f2-f9fcf372d3e8.png"></p><p>运行 .&#x2F;nuttx 后会出现一个新的 shell，这个是 Nuttx 的终端 nsh，输入 help 命令可查看当前可用命令。</p><p>输入 hello 后按回车，即执行 hello 的程序，然后打印出 hello world。<br>退出 nsh 需要使用命令 poweroff，而不能使用 Ctrl-C 结束程序。</p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>hello 程序所在位置为：apps&#x2F;examples&#x2F;hello&#x2F;hello_main.c 中，打开文件可以可进行修改然后编译运行。</p><p>将我之前移植 FreeRTOS 时所自带的 Posix 测试程序，替换 hello_main.c 的内容，修改入口函数名为 main，然后重新编译运行。</p><p>无需任何移植，即可完美兼容 POSIX 接口的程序。</p><p><img src="https://files.mdnice.com/user/11205/4eab2c66-4491-41a7-8b99-3cf0e2c1c758.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是我关于 Nuttx 学习记录的第一篇文章，如有不严谨或者错误的地方欢迎大家指出。<br>在下一篇会讲到如何新建一个自己的工程以及如何修改 Nuttx 的配置，给 Nuttx 添加功能。</p><p>该项目的两个仓库，我已合并成一个 github 仓库方便下载，后续学习记录的代码和笔记都会同步到改仓库，有需要可点文末阅读原文自取。</p><p>如果喜欢的话，希望大家多多点赞转发。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://os.51cto.com/article/584942.html">https://os.51cto.com/article/584942.html</a><br><a href="https://nuttx.apache.org/docs/latest/introduction/about.html">https://nuttx.apache.org/docs/latest/introduction/about.html</a><br><a href="https://github.com/apache/incubator-nuttx">https://github.com/apache/incubator-nuttx</a><br><a href="https://cwiki.apache.org/confluence/collector/pages.action?key=NUTTX">https://cwiki.apache.org/confluence/collector/pages.action?key=NUTTX</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
